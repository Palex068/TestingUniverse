# 2. Планета теории

## Содержание

+ [2.1 Планета теории](#21-планета-теории)
+ [2.2 Методологии разработки](#22-методологии-разработки)
+ [2.3 Подходы к разработке](#23-подходы-к-разработке)
+ [2.4 Контроль и обеспечение качества](#24-контроль-и-обеспечение-качества)
+ [2.5 Процесс тестирования](#25-процесс-тестирования)
    + [Планирование](#планирование)
    + [Мониторинг и контроль](#мониторинг-и-контроль)
    + [Проектирование](#проектирование)
    + [Реализация](#реализация)
    + [Выполнение](#выполнение)
    + [Завершение](#завершение)
+ [2.6 Принципы тестирования](#26-принципы-тестирования)
    + [Тестирование не может доказать отсутствие багов, только их наличие](#тестирование-не-может-доказать-отсутствие-багов-только-их-наличие)
    + [Исчерпывающее тестирование невозможно](#исчерпывающее-тестирование-невозможно)
    + [Раннее тестирование](#раннее-тестирование)
    + [Бойтесь парадокса пестицидов!](#бойтесь-парадокса-пестицидов)
    + [Кластеризация багов](#кластеризация-багов)
    + [Тестирование зависит от контекста](#тестирование-зависит-от-контекста)
    + [Заблуждение об отсутствии багов](#заблуждение-об-отсутствии-багов)
+ [2.7 Пирамида тестирования](#27-пирамида-тестирования)
    + [Модульное тестирование](#модульное-тестирование)
    + [Интеграционное тестирование](#интеграционное-тестирование)
    + [Системное тестирование (System testing)](#системное-тестирование-system-testing)
    + [Приемочное тестирование (Acceptance testing)](#приемочное-тестирование-acceptance-testing)
+ [2.8 Виды тестирования по доступу к коду](#28-виды-тестирования-по-доступу-к-коду)
    + [Тестирование черного ящика (black box testing)](#тестирование-черного-ящика-black-box-testing)
    + [Тестирование белого ящика (white box testing)](#тестирование-белого-ящика-white-box-testing)
    + [Тестирование серого ящика (grey box testing)](#тестирование-серого-ящика-grey-box-testing)
+ [2.9 Виды тестирования по формализации подхода к тестированию](#29-виды-тестирования-по-формализации-подхода-к-тестированию)
+ [2.10 Виды тестирования по критерию запуска программы](#210-виды-тестирования-по-критерию-запуска-программы)
+ [2.11 Виды тестирования по степени автоматизации](#211-виды-тестирования-по-степени-автоматизации)
+ [2.12 Виды тестирования по ожидаемому поведению системы](#212-виды-тестирования-по-ожидаемому-поведению-системы)
+ [2.13 Виды тестирования по изменению кода](#213-виды-тестирования-по-изменению-кода)
+ [2.14 Виды тестирования в зависимости от цели](#214-виды-тестирования-в-зависимости-от-цели)

[Оглавление](/TestingBegin/README.md)

# 2.1 Планета теории

[Планета теории:](https://youtu.be/kGYDebheyv4)

<hr>

[Содержание](#содержание)

# 2.2 Методологии разработки

[Видео-шпаргалка урока "Методологии разработки":](https://youtu.be/SAjKZijnI4I)

> **Релиз** — это готовая версия программы, доступная для всех пользователей.

## Методологии разработки

Мы уже понимаем, что разработка программного обеспечения осуществляется в соответствии с определенными правилами или "канонами". Это приводит нас к понятию "жизненного цикла ПО" (SDLC - Software Development Life Cycle).

**Жизненный цикл ПО** охватывает период времени с момента возникновения идеи продукта до его вывода из эксплуатации. Он состоит из следующих этапов: концепт, описание требований, дизайн, реализация, тестирование, инсталляция и наладка, эксплуатация и поддержка и, иногда, этап вывода из эксплуатации.

**Жизненный цикл разработки ПО** является концепция, которая описывает комплекс мероприятий, выполняемых на каждом этапе разработки программного обеспечения:
+ Анализ требований: на этом этапе формулируется техническое задание (ТЗ), определяются сроки выполнения задач и составляется план работ. Также важно учитывать возможные риски.
+ Дизайн системы: здесь разрабатывается прототип, создается дизайн-макет, выбирается платформа для программирования. Команде назначаются роли, их обязанности четко определяются.
+ Разработка: команда приступает к написанию кода продукта в соответствии с требованиями, указанными в техническом задании.
+ Тестирование: на этом этапе происходит проверка продукта, когда код уже написан. Если тестирование успешно завершается, работу можно считать практически завершенной.
+ Техническая поддержка: после выпуска продукта команда разработчиков поддерживает его работу на стабильном уровне, собирая обратную связь от пользователей и исправляя ошибки, если они возникают.

Жизненный цикл разработки ПО предоставляет структуру и руководство для эффективной разработки и поддержки программных продуктов. Каждый этап важен и выполняется последовательно, обеспечивая качество и успешное внедрение программного решения.

![02](/TestingBegin/img/02_01.jpg)

**Waterfall**, также известная как водопадная или каскадная модель разработки, была описана в 1970 году и повторяет этапы жизненного цикла разработки ПО. Она предлагает решать задачи последовательно, без возврата на предыдущие этапы.

Основные принципы Waterfall:
+ Следуйте правилам: Waterfall предлагает строго следовать определенным правилам и шаблонам, определенным на каждом этапе разработки.
+ Нет ТЗ - нет продукта: создание детального технического задания считается ключевым аспектом водопадной модели. Отсутствие четкого ТЗ может привести к проблемам в процессе разработки.
+ Чем подробнее ТЗ, тем лучше продукт: водопадная модель предполагает, что более подробное и полное техническое задание приведет к более качественному продукту.
+ Следите, чтобы не было изменений: водопадная модель стремится минимизировать изменения во время разработки, чтобы избежать проблем согласования и контроля версий.

С развитием и распространением программного обеспечения стало понятно, что необходимо глубже погружаться в проект, взаимодействовать с командой и предлагать новые решения. Водопадная модель разработки не предоставляла достаточной гибкости для такого подхода. Именно в этот момент возник Agile, предлагающий более гибкий и итеративный подход к разработке ПО.

**Agile** - это группа методик, предназначенных для гибкого управления продуктом. Основная идея заключается в разбиении процесса разработки на небольшие временные промежутки, называемые спринтами. В течение каждого спринта команда разработки создает определенную часть продукта, которая может быть протестирована. Такой подход позволяет вносить корректировки и изменения на любом этапе разработки.

![02](/TestingBegin/img/02_02.jpg)

Манифест гибкой разработки ПО - это документ, содержащий ключевые принципы и ценности гибкого подхода к разработке программного обеспечения. Вот основные принципы, изложенные в манифесте:
+ Люди важнее инструментов: главным фокусом должны быть люди, включая разработчиков, заказчиков и пользователей. Успех проекта зависит от эффективного взаимодействия и сотрудничества между людьми.
+ Качество продукта важнее документации: хотя документация является важной частью разработки, основной приоритет должен быть уделяться созданию качественного программного продукта, который полностью удовлетворяет потребности пользователей.
+ Взаимодействие с заказчиком важнее контракта: Agile подчеркивает необходимость непрерывного взаимодействия с заказчиком, чтобы понять и удовлетворить его потребности. Взаимодействие и обратная связь с заказчиком имеют большую ценность, чем формальные контракты и документы.
+ Готовность к изменениям важнее установленного плана: Agile признает, что требования и условия могут меняться со временем. Гибкий подход предполагает готовность к принятию изменений и быструю адаптацию для достижения лучших результатов.

Манифест гибкой разработки ПО служит руководством для команд, стремящихся к гибкости и улучшению процесса разработки, чтобы достичь максимальной ценности для пользователей и заказчиков.

## Пример
Рассмотрим нашу тему на примере производственного процесса:

Waterfall завод мороженого

В классической модели Waterfall для разработки нового вида мороженого генеральный директор поручает технологу задачу и ждет от него готового продукта. Технолог разрабатывает мороженое на основе собственных предположений и опыта, без участия других сотрудников или маркетинговых исследований. Затем генеральный директор пробует продукт и решает, нужно ли его переделывать или нет. После этого варщики получают технологические карты и запускают продукт в производство, а продавцы продают упакованное мороженое. Оценка производится только одним или несколькими членами команды.

Agile завод мороженого

В гибком подходе Agile для разработки нового вида мороженого вовлечены не только технологи и сотрудники маркетинга, но и менеджеры по продажам, логисты, повара и даже реальные покупатели. Команда работает без иерархии, сосредоточиваясь на создании нового продукта для удовлетворения потребностей покупателей. Каждый участник команды вносит свой вклад и оценивает результаты работы, обеспечивая обратную связь для дальнейшего улучшения продукта.

В отличие от классического подхода, Agile позволяет команде быть гибкой, вносить изменения на протяжении всего процесса и активно взаимодействовать с заказчиками и потребителями. Это позволяет достичь более успешных результатов и удовлетворить потребности рынка.

<hr>

[Содержание](#содержание)

# 2.3 Подходы к разработке

[Видео-шпаргалка "Подходы к разработке":](https://youtu.be/i8yLyksLpXM)

## Подходы к разработке

В разработке любого ПО существуют два основных подхода: 
+ итеративный и
+ непрерывный. 

Они отличаются методами работы и организацией процесса.

Итеративный подход предполагает, что заказчики или пользователи видят результаты работы только в конце каждого этапа. В течение разработки они продолжают использовать предыдущую версию продукта. Этот подход позволяет команде сосредоточиться на каждом этапе и внести все необходимые изменения до перехода к следующему этапу

![02](/TestingBegin/img/02_03.png)

Непрерывный подход, наоборот, предоставляет пользователям возможность получать новые версии продукта ежедневно или на более коротких временных интервалах. Это позволяет пользователям уже на ранних этапах взаимодействовать с новыми функциями и давать обратную связь.

![02](/TestingBegin/img/02_04.png)

Непрерывный подход является наиболее популярным в настоящее время. Он основан на концепции Continuous Integration, Continuous Delivery (CI/CD) - непрерывной интеграции и доставки. 

CI/CD - это автоматизация процесса разработки и доставки новых модулей ПО конечным пользователям. В рамках непрерывного подхода решаются задачи автоматизации сборки, упаковки, тестирования и развертывания ПО в различных окружениях. Такой подход минимизирует ошибки и уязвимости ПО.

![02](/TestingBegin/img/02_05.png)

CI/CD можно сравнить с конвейерным производством. Оба подхода характеризуются четким распределением труда, непрерывным потоком работы и параллельным выполнением нескольких задач.

CI/CD зависит от работы тестировщиков и разработчиков:
+ Тестировщики следят за тем, чтобы новые изменения не негативно повлияли на качество продукта.
+ Разработчики автоматизируют процесс релиза ПО и его доставки.

Благодаря CI/CD пользователи могут получать новые функции и возможности сразу, а команда разработки получает страховку от возможных ошибок и проблем при сборке и доставке ПО.

<hr>

[Содержание](#содержание)

# 2.4 Контроль и обеспечение качества

[Видео-шпаргалка урока "Контроль и обеспечение качества":](https://youtu.be/bbu6l0woJcA)

> **Качество программного обеспечения** — способность программного продукта при заданных условиях удовлетворять установленным или предполагаемым потребностям.

## Quality assurance, Quality control и Testing. Who is who?
Если с тестированием все понятно, то с обеспечением и контролем качества не все так однозначно. На первый взгляд может показаться, что это совершенно одинаковые понятия. Так это или нет? Сейчас мы с вами будем разбираться в этом. 

Посмотрите на схему: 

![02](/TestingBegin/img/02_06.png)

Если рассмотреть тестирование, контроль качества и обеспечение качества, то можно заметить, что все три понятия тесно связаны друг с другом и являются взаимосвязанными компонентами. Однако они имеют свои особенности и цели.

1. **Тестирование (Testing)** - это первый уровень и включает проверку программного продукта на соответствие его требованиям. <br>
Основная цель тестирования заключается в том, чтобы убедиться, что ожидаемые результаты совпадают с фактическими. На этом уровне проводятся функциональные и другие виды тестирования, чтобы проверить работоспособность и соответствие продукта заранее установленным требованиям.<br>
Например, в случае интернет-магазина, тестирование будет включать проверку функционала кнопки "Купить" и сравнение ее с макетом.

2. **Контроль качества (Quality Control, QC)** - это второй уровень и включает в себя не только тестирование, но и контроль соответствия продукта заранее согласованному уровню качества.<br>
Основная задача контроля качества - предоставить объективную оценку качества продукта на различных этапах разработки. Контроль качества направлен на выполнение установленных требований к качеству.<br>
Вернемся к интернет-магазину. QC даст отмашку на релиз, если не заполнена страница благодарностей, на которую можно перейти из футера (подвала) сайта. Или, например, не даст добро, если страница благодарностей заполнена, а каталог пустой. 

3. **Обеспечение качества (Quality Assurance, QA)** - это третий уровень и представляет собой проактивную работу, направленную на создание уверенности, что требования к качеству будут выполнены.

Основная задача обеспечения качества - разработка методик и процессов, которые помогают минимизировать количество дефектов при тестировании. В область обеспечения качества могут входить такие действия, как тестирование документации, ревью кода на соответствие стандартам, внедрение методик работы с качеством. Обеспечение качества направлено на создание уверенности в том, что требования к качеству будут выполнены.

В случае интернет-магазина, обеспечение качества может включать анализ эффективности текущего процесса разработки для дальнейшего оптимизации работы, чтобы доставлять фичи пользователям раньше конкурентов.

При более полном понимании можно обратиться к [ГОСТ Р ИСО 9000-2015](https://sudact.ru/law/gost-r-iso-9000-2015-natsionalnyi-standart-rossiiskoi/gost-r-iso-9000-2015/#:~:text=ГОСТ%20Р%20ИСО%209000-2015.%20Национальный,(IDT)%20Дата%20введения%20-%202015-11-01)

**P.S.**

>QA engineer, QC специалист или тестировщик —  это все одна вакансия или все три разные? На какие вакансии откликаться, я же учусь на тестировщика. 

На сайтах по поиску работы можно увидеть следующие вакансии:

![02](/TestingBegin/img/02_07.png)

В описании работы чаще всего будут обязанности тестировщика и не будет ни слова об улучшении качества. 

Эта путаница началась уже давно, найти и искоренить ее истоки невозможно, поэтому смело можно отправлять свое резюме и на QA, и на тестировщика, и даже на QC (если найдете такую вакансию, связанную со сферой ИТ), главное, чтобы ваши знания и навыки отвечали перечисленным в ней обязанностям.

<hr>

[Содержание](#содержание)

# 2.5 Процесс тестирования

[Видео-шпаргалка урока "Процесс тестирования"](https://youtu.be/ITzoL_u0H0E)

> **ISTQB (International Software Testing Qualifications Board)** - это международная организация, занимающаяся сертификацией тестирования программного обеспечения.

## Процесс тестирования

Вопреки ожиданиям, процесс тестирования несколько шире, чем «садишься за комп и тестишь». Помимо непосредственного взаимодействия с объектом тестирования, существуют как подготовительные этапы, так и последующие. Для того, чтобы проверки стабильно давали точную информацию о качестве продукта, они документируются и регулярно актуализируются. 

Для измерения эффективности тестирования и отслеживания общего качества используются специальные метрики. На основании полученных результатов и рассчитанных метрик составляются отчеты. По разным оценкам, работа с документацией занимает от 50% до 70% времени тестировщика, на само же тестирование тратится оставшаяся часть.

Настроенные процессы — залог успешной реализации проекта, и тестирование в этом успехе играет не последнюю роль.

Четкое понимание того, что, как и в какой момент делать, экономит время, придает уверенность, устанавливает хорошие взаимоотношения в команде. Подобно фундаменту здания, который никто не видит, но на который все опирается. Сами по себе процессы не могут обеспечить успешность проекта, но могут существенно упростить ее достижение. Процесс тестирования не является чем-то отдельным, он плотно переплетается с другими процессами, входящими в разработку и выпуск программного обеспечения.

Дисклеймер: в качестве основы для описания процесса тестирования была взята Программа подготовки базового уровня 2018 года ISTQB, доступная для скачивания по [ссылке](https://www.rstqb.org/ru/istqb-downloads.html) (на русском и английском языках) 

<hr>

[Содержание](#содержание)

## Планирование

Прежде всего оговоримся, что весь описываемый процесс не обязательно представляет собой жесткую последовательность. Разные этапы могут идти параллельно, потому что тут не успели, а там сделали раньше. Могут возникнуть непредвиденные обстоятельства, из-за которых придется возвращаться к сделанному ранее и переделывать по-новому. 

Процессы (в том числе тестирования) в разных компаниях или в одной компании на разных проектах могут существенно отличаться, поэтому данное описание не является догмой на все 100%. И, наконец, несмотря на то, что мы говорим о проекте в целом, процесс может применяться и отдельно к его частям. Например, выпуск новой версии вполне может пройти все описанные  здесь этапы. Обо всем этом надо помнить в процессе изучения и осмысления материала.

Планирование тестирования — этап составления планов (внезапно!). Тест-план включает в себя всю общую информацию о проекте. Например, требования и дизайн продукта. Под требованиями подразумевается документ(ы), в котором сформулировано, какую функциональность продукт должен предоставлять пользователю. Техническое задание, спецификации, требования, юзер стори, любые аналогичные документы. Требования могут быть расписаны в разных формах, но они в любом случае включают в себя описание работы конечного продукта. Например:
+ пользователь должен иметь возможность авторизоваться на сайте;
+ авторизованный пользователь должен иметь возможность зайти в личный кабинет;
+ в личном кабинете пользователь должен иметь возможность прикрепить банковскую карту с целью использования ее для будущих покупок на сайте.

Дизайном называют макеты будущего продукта, отрисованные в графическом редакторе. Не так давно многое рисовалось в фотошопе, но сейчас чаще используются специальные программы, имеющие «заточенный» для этих целей интерфейс и функциональность. Например, довольно популярна Figma — мы еще столкнемся с ней на следующих уроках, но можете погуглить ради интереса уже сейчас. Требования, дизайн и любые другие описывающие будущий продукт вещи называются «тестовым базисом».

Помимо этого, план тестирования может включать в себя, например, расписание тестирования, т.е. когда будет тестироваться какая часть продукта. Откуда это может быть известно? Нельзя разрабатывать продукт по принципу «когда будет готово», все работы имеют временные оценки и установленные сроки реализации. Соответственно, когда будет готова конкретная функциональность, тогда и начнется ее тестирование.

Еще к плану тестирования можно приложить анализ рисков, список метрик с формулами, бюджет, критерии начала и окончания тестирования, образцы тестовой документации, описание используемых техник и технологий. Вообще что угодно из того, о чем можно договориться «на берегу», когда разработка еще не начата. Вся общая информация, хоть как-то касающаяся тестирования — здесь.

<hr>

[Содержание](#содержание)

## Мониторинг и контроль

Этап мониторинга и контроля не является этапом «до» или «после», это этап «во время». Во время всего проекта, если быть точнее. Мониторинг и контроль тестирования подразумевают непрерывное отслеживание фактического хода работы и сверку его с тестовым планом. Помните, на этапе планирования мы говорили о расписании? Крайне важно не только иметь такой документ, но и регулярно к нему обращаться, а в случае расхождения вовремя принимать меры, чтобы скорректировать ход работ. Расчет метрик тестирования также входит в мероприятия данного этапа. 

Одной из метрик является процент пройденных проверок — завтра у нас выходит новая версия, а сегодня она протестирована только на 10% — значит, что-то идет не так. Например, новую версию установили только сегодня. Или ее установили неделю назад, а мы ничего не тестировали. Ищем причину, устраняем ее, продолжаем работу в штатном режиме.

Разумеется, отчетность — тоже элемент данного этапа. Стандарт ISO/IEC/IEEE 29119-3 выделяет два вида отчетов: отчет о ходе тестирования и отчет о завершении тестирования. Форма и содержание отчетов могут сильно отличаться от проекта к проекту, а также в зависимости от целей, которые преследуют конкретные отчеты, и аудитории, для которой они составляются. 

Например, для сложных, формальных проектов с большим числом заинтересованных лиц может потребоваться более подробная и строгая отчетность. В гибкой разработке отчеты о ходе тестирования могут быть частью обсуждения на ежедневных встречах, поэтому составляются в автоматическом или полуавтоматическом режиме (например, путем выгрузки списка задач, по которым велись работы, из баг-трекера).

В целом, для понимания того, что что-то идет не так, требуется отслеживать то, как оно идет в данный момент и знать, как оно должно идти. Мониторинг и контроль тестирования это в первую очередь задача руководства. Для рядового же сотрудника (как правило) данный этап заканчивается на выполнении регламентированных рутинных действий по ежедневному заполнению форм, если они не заполняются автоматически по мере его работы.

<hr>

[Содержание](#содержание)

## Анализ

На этапе анализа занимаются… анализом (бадум тссс!). Крайне здравый вопрос: «Анализом чего»? И здесь мы приходим к фундаментальному принципу трассируемости, о котором будем упоминать постоянно и который красиво выстроится у нас к концу этого урока. Мониторинг и контроль стоит как бы в стороне, т.к. идет параллельно всем другим этапам. Но поставить его в самое начало или в самый конец списка было бы не очень логично. 

Из-за этого он вклинился на второе место и немного поломал последовательность, но это не страшно. Итак, на этапе анализа мы анализируем тестовый базис, собранный на этапе планирования. Напомним, что тестовым базисом у нас называются описывающие будущий продукт требования и дизайн. 

Анализировать их можно с двух сторон:
1. Анализ базиса на наличие ошибок. Все документы, входящие в базис, тоже можно тестировать и выявлять такие баги, как отсутствие полноты, однозначности, достижимости, тестируемости и актуальности. Например, если на макете главной страницы кнопка «личный кабинет» расположена в десяти разных местах, это вполне может быть поводом уточнить, не стоит ли сократить это количество хотя бы до 9. Или требование нарисовать 7 перпендикулярных линий (погуглите, ролик веселый)...
2. Анализ базиса с целью выявления тестовых условий. Под тестовыми условиями понимается конкретное утверждение, которое можно проверить. Например, «кнопка должна быть красивенькая» — не тестовое условие, а «кнопка должна быть 20х40, цвета FF0000, с надписью цвета FFFFFF «Старт» шрифтом Times new roman размера 9,5» — целый набор тестовых условий.

Таким образом, по завершении этого этапа мы должны получить полностью непротиворечивые, абсолютно точные и максимально подробные документы тестового базиса и целый набор таких же качественных тестовых требований.  

<hr>

[Содержание](#содержание)

## Проектирование

И вот наступает этап проектирования, на котором мы будем… проектировать (никогда не надоест). Но вопросы: «Что именно?» и «Как?» здесь более чем уместны, давайте найдем на них ответ. Мы будем писать высокоуровневые тест-кейсы на основании тестовых условий. Для начала очень кратко разберем, что такое тест-кейс (подробно о тест-кейсах поговорим в модуле 3). Тест-кейс, он же тестовый сценарий, представляет из себя описание последовательности конкретных шагов (действий), которые следует пройти для проверки какой-либо функциональности. Как правило, для каждого шага прописывается ожидаемый результат, т.е. что должно произойти при выполнении действия, например:

Нажать ЛКМ на иконку корзины в правой верхней части страницы — Страница корзины открыта.

По сути своей, это уже тест- кейс — очень короткий, но все же. На практике тест-кейсы обычно длиннее. Например, открыть каталог, добавить товар в корзину, потом перейти в нее и убедиться, что товар добавился — уже вполне себе тест-кейс «Проверка добавления товара в корзину». Высокоуровневый тест-кейс характеризуется отсутствием привязки к конкретным данным — то есть мы не указываем какой именно товар из какого раздела каталога должен быть добавлен. Или, скажем, при проверке авторизации пишем «ввести корректный логин и пароль» вместо указания конкретных логина и пароля.

Примечание: в других популярных источниках такое деление на высокоуровневые и обычные тест-кейсы отсутствует, но все же ISTQB достаточный авторитет, чтобы о нем рассказать.

Тест-кейсы пишутся на основании тестовых условий. Вспомним нашу кнопку (которая «Старт», а не которая красивенькая), нам потребуется проверить ее цвета, надпись и шрифт. Так как тест-кейсы у нас высокоуровневые, мы просто укажем что ее параметры корректны, «соответствуют макету» (предположим, что мы взяли их с макета). В такой формулировке тест-кейс можно будет применить не только к конкретно этой кнопке, а вообще ко всем кнопкам, изображенным на макете (т.е. вообще ко всем кнопкам нашего продукта, т.к. макет должен отображать итоговый вид).

И вот смотрите, как интересно у нас уже выстраиваются рабочие продукты каждого этапа по принципу трассируемости: сначала из макета, представляющего тестовый базис, были выделены тестовые условия, а уже на их основании написан высокоуровневый тест-кейс. То ли еще будет, идем дальше!

<hr>

[Содержание](#содержание)

## Реализация

На этапе реализации мы, как ни странно, не реализуем. Данный перевод английского implementation хоть и является самым распространенным, в данном случае крайне неудачен. В первоисточнике слово употребляется в значении «снабжение инструментами» и, собственно, именно это и происходит на данном этапе.

Инструментами в нашем случае являются, например, все необходимые для тестирования вспомогательные программы. Баг-трекер, в котором будут описываться все найденные баги и отслеживаться прогресс их исправления. Сначала баг-трекер необходимо выбрать, затем оплатить его использование, после чего создать нужное количество учетных записей для всех, кто будет участвовать в процессе разработки. 

Также понадобится настроить баг-трекер —  уже упомянутая ранее Jira позволяет очень гибко кастомизировать набор полей, которые будут использоваться в ходе работы. Помимо банальных заголовка, описания, версии продукта и окружения, на котором воспроизводится баг, можно, например, добавить список компонентов продукта (отдельные разделы интернет— магазина — каталог, корзина, личный кабинет и т.д.). Или с помощью системы лейблов создать сложную детализацию функциональности, который затрагивает баг (лучше не надо, но возможность есть). Также инструментами будет дополнительное ПО для выполнения каких-то специфических действий —  для работы с базой данных проекта, для проведения нагрузочного тестирования и т.д.

Нельзя забывать о настройке стендов для тестировщиков, разработчиков, для других заинтересованных (менеджмента, инвесторов). Пусть вас не пугает слово «стенд» —  под ним подразумевается версия продукта, закрытая для доступа посторонних. То есть это банально тот же сайт интернет-магазина, что в итоге будет выпущен, но только его ранняя версия. С каталогом из 5 товаров, с регулярно отваливающейся корзиной и в принципе половиной функциональности в состоянии «еще не готово». Зато имеющаяся функциональность уже надо тестировать. 

То есть, если нашим продуктом является сайт bestshop.org, то по адресу test-bestshop.org может располагаться стенд для тестировщиков, dev-bestshop.org —  стенд разработчиков, а manage-bestshop.org —  стенд для менеджмента. 

Разработчики пишут фичи и смотрят как они работают на своем стенде, потом набор фич объединяется вместе и составляет новую версию продукта —  ее раскатывают на стенде тестировщиков и она тестируется, а последняя стабильная протестированная версия устанавливается на менеджерский стенд, чтобы начальство могло отслеживать ход работ, показывать его заказчику, инвесторам и еще кому угодно, кто должен это увидеть. 

Сами стенды могут быть развернуты, например, во внутренней сети компании и извне на них зайти никто никогда не сможет. Устройство всей этой системы, в том числе и с «железной» стороны (программы должны запускаться на компьютерах, которые еще купить и настроить сначала надо) — тоже часть этапа реализации.

Этот этап тоже мог бы выпасть из принципа трассируемости, если бы на этом его описание и окончилось, но нет. Также на этом этапе подготавливаются тестовые данные. Те самые тестовые данные, в отрыве от которых пишутся высокоуровневые тест-кейсы. То есть, если мы сложим эти два компонента, то получим что? Правильно, готовые к употреблению тест-кейсы.

Тест-кейсы могут укладываться в последовательности в рамках этого этапа (логично сначала протестировать авторизацию, а потом личный кабинет — можно сэкономить немного времени).

В целом, этап реализации можно было бы назвать этапом «настройки» или этапом «подготовки к выполнению», но первоисточник — есть первоисточник.

<hr>

[Содержание](#содержание)

## Выполнение

Ну что ж, мы прошли долгий путь и теперь, вооруженные до зубов спецификациями, установленными программами, настроенными доступами и целой кучей тест-кейсов мы переходим на этап выполнения, на котором будем ВЫПОЛНЯТЬ (вы же не думали, что эта шутка могла закончиться?) тестирование. Как мы будем это делать? 

Да, в общем-то, вот он, тот самый этап «протыкивания», этап «берешь и тестишь», с которым многие и ассоциируют профессию тестировщика (из тех, кто вообще о ней знает). У нас есть набор действий, ожидаемый результат которых заранее известен (тест-кейсы). Мы производим эти действия, отслеживая получаемый результат. Если полученный результат не совпал с ожидаемым, на это пишется баг-репорт, который уходит разработчикам. Результат каждого прохождения тест-кейсов (pass/fail) документируется на протяжении всего времени существования проекта.

Остановимся чуть подробнее на этом моменте, чтобы процесс тестирования ПО стал немного понятнее. До сих пор мы описывали все этапы так, как будто однажды завершив один этап, мы переходим к следующему и больше назад не возвращаемся. В начале урока был дисклеймер о том, что последовательность не жесткая, вот его-то мы расширим и углубим.

К нам на стенд приехала самая первая версия продукта, которую мы должны протестировать. Это маленький кусочек функциональности, например, страница авторизации. При успешном вводе логина пароля нам показывается заглушка —  страница с надписью «авторизация успешна». 

Если же логин и пароль не подходят друг к другу, демонстрируется соответствующее сообщение. Функциональность протестирована, тест-кейсы пройдены, баг-репорты написаны. Приезжает новая версия, в которой исправлены баги предыдущей плюс добавлена новая функциональность — вместо заглушки теперь показывается главная страница, только на ней ничего не работает (это прикрутят уже в следующей версии).

И вот важный момент, каковы наши действия:
+ Проверяем, исправлены ли баги предыдущей версии (те, которые разработчики пометили как исправленные и передали нам), в зависимости от результата переводим их в статус исправленных или возвращаем разработке на исправление;
+ Проводим тестирование новой функциональности, проходим тест-кейсы, пишем баг-репорты;
+ Проводим полное тестирование оставшейся функциональности (это называется регрессионное тестирование или сокращенно регресс), чтобы убедиться, что исправление багов и добавление новых фич его не сломало;
+ В ожидании новой версии работаем с документацией, т.е. проверяем актуальность имеющихся тест-кейсов, пишем новые, считаем метрики и т.д.;

Когда на наш стенд установят новую версию, все повторится по новой. Возможно, в какой-то момент будет внедряться фича, которая не была изначально запланирована, и в отношении нее весь тестовый процесс начнется сначала, при этом реализация запланированных фич прерываться не будет, они также будут выходить в рамках новых версий как было задумано изначально. Процессы будут идти параллельно, пока в определенный момент новая фича просто не станет частью новой версии продукта. 

Надеюсь, нам удалось передать, что процесс тестирования — это не лестница, это река.

<hr>

[Содержание](#содержание)

## Завершение

Этап завершения необязательно подразумевает под собой завершение всего проекта. Речь идет о завершении какой-то части работ, которую можно выделить. Это может быть банально выпуск новой версии. Что-то более крупное, например, выход продукта в релиз. Завершение проекта — тоже вполне себе подходящий повод, но все же он бывает один раз, а этапов завершения в процессе тестирования подразумевается гораздо больше.

Это этап подведения итогов, учета возникших проблем и разработки способов их избежать в будущем. Тот момент, когда надо остановиться, оглянуться на проделанную работу и сказать «Хм, а ведь неплохо. Но в будущем можно поменять вот тут и тут и получится еще лучше». И обязательно сделать так в следующей версии, следующем релизе, следующем проекте. Ведь полученный опыт, дополнительно осмысленный на данном этапе, не позволит повторить допущенные ошибки. Время собирать камни.

Вещественно этап воплощается в отчетах о проведенных проверках и их результатах, а также в изменениях в работе команды. Об изменениях говорить не будем — они индивидуальны для каждого проекта, каждой команды. А вот на отчетах остановимся, снова вспомнив принцип трассируемости в процессе тестирования. Возьмем отчет, в котором прописано, что баг А был обнаружен при прохождении тест-кейса Б, который в последней на данный момент версии продукта был пройден успешно. Тест-кейс Б был написан на основании тестового условия C, выделенного из пункта D документа E, представляющего собой список требований, выявленных аналитиком Ивановым при общении с заказчиком. 

На самом деле, правильно называть наш принцип «принципом двунаправленной трассируемости», ведь при его соблюдении мы можем проследить путь как от требования к результату в конечном продукте, так и от конечного продукта к конкретному требованию. И на этом мы ЗАВЕРШАЕМ теорию процесса тестирования (потому что никто не ждет испанскую инквизицию).

<hr>

[Содержание](#содержание)

# 2.6 Принципы тестирования

[Видео-шпаргалка "Принципы тестирования"](https://youtu.be/y7vdkH1aqxg?si=Cfrni_M-RnxIGxIs)

## Начнем наше обучение с азов. 

Итак, принципов тестирования всего 7 — как цветов радуги, чудес света, смертных грехов, дней недели и много чего еще. Выбирайте любой образ, который поможет лучше это запомнить. Как и большинство принципов, они редко напрямую используются на практике, но при этом любое тестирование предполагает их соблюдение. Для начала перечислим их:
1. Тестирование не может доказать отсутствие багов(только их наличие);
2. Исчерпывающее тестирование невозможно по определению;
3. Раннее тестирование позволяет сэкономить ресурсы;
4. Парадокс пестицидов;
5. Кластеризация багов;
6. Тестирование зависит от контекста;
7. Заблуждение об отсутствии багов;

Хотите стать хорошим тестировщиком? Так вот, этот список надо не просто зазубрить, а вникнуть в каждый пункт, понять его. Возможно, смысл одних очевиден (или только кажется таковым), а насчет других у вас отсутствуют какие-либо догадки. Рассмотрим каждый подробно.

<hr>

[Содержание](#содержание)

## Тестирование не может доказать отсутствие багов, только их наличие.

*Месяца два назад в интернет-магазине заказала кофту с милым принтом. Она не пришла, в сроке доставке было написано 10-40 дней. Написала продавцу. Он не соглашается отдавать мне деньги, указывая на то, что я его обманываю. Просит прислать фотку, доказывающую, что кофты нет. Я просто чего-то не понимаю, да? Сейчас отправила ему фотку пустого стола. Отпишусь, когда ответит.*

Можно ли доказать отсутствие чего-либо? Надо ли вообще его доказывать? Может, это оппонент должен доказать наличие чего-либо, являющегося предметом спора? Однако, тестирование процесс сугубо практический и, не отвлекаясь на глубокие мысли, попробуем разобраться в первом его принципе.

Представим, что в ходе тестирования мы провели какую-либо проверку и получили тот результат, который и ждали. Например, кликнули по иконке корзины на сайте интернет-магазина и открылась страница корзины. Значит ли это, что любой пользователь в любой ситуации повторит наше действие и получит тот же результат? Ответ: «Нет». Ведь пользователь это может делать в другом браузере, или в другой версии того же браузера, что и мы. Или у него может быть другая операционная система (или версия), другая конфигурация компьютера. В конце концов, может произойти что-то непредвиденное — «скакнет» электричество, на секунду оборвется интернет-связь, и в итоге корзина не откроется. 

Таким образом, отсутствие багов во время проверки не может гарантировать отсутствия багов при подобных действиях в другое время. Из этого делаем вывод,что тестирование не может доказать отсутствие багов.

А что же в обратную сторону, оно тоже работает? И да, и нет. С одной стороны, если мы нашли баг, это не значит, что он повторится у пользователя. Даже если повторим проверку 100 раз и 100 раз получим не то, что ждали, все еще не значит, что он есть. Но с другой стороны, мы точно знаем, что баг может возникнуть у пользователя, раз он возник у нас. А раз баг есть, значит, что-то его вызывает. Следовательно, нужно найти причину этого бага и устранить ее. 

Исходя из этого, мы получаем вторую часть принципа — тестирование может доказать наличие багов.

Здесь может показаться, что тестирование не так уж и нужно, раз не может ничего гарантировать. Да и тестировщик ни за что ответственности не несет — пропустил баг и ладно, отсутствие багов никто и не гарантировал. Все совсем не так. Как правило, для любого разрабатываемого ПО подразумеваются (и напрямую указываются) некие «нормальные условия», при которых оно должно работать, и именно в этих условиях проводятся проверки.

**P.S.**

Довольно хорошо иллюстрирует условия разработка мобильных приложений для устройств на iOS. Есть достаточно ограниченный список моделей айфонов и версий их операционной системы. Можно запланировать, что для запуска приложения нужна модель не старше определенной и версия iOS также не ниже определенной. При соблюдении этих условий приложение будет работать как задумано, в остальных случаях за результат никто не отвечает. И, соответственно, тестирование не проводится. С андроидом ситуация похожая, но там все чуть сложнее, т.к. у каждого производителя своя линейка моделей. Или вот еще пример: если вы напишете в техподдержку популярного баг-трекера Jira, что он некорректно работает на вашем макбуке, то получите ответ, что устройства от Apple официально не поддерживаются. В общем, это ваши проблемы, что у вас там не работает. Никто не будет разбираться до тех пор, пока не запустите на поддерживаемой конфигурации. Такие дела.

<hr>

[Содержание](#содержание)

## Исчерпывающее тестирование невозможно

Я в своем познании настолько преисполнился…

В конце описания первого принципа мы как раз вплотную подошли ко второму. Почему бы не взять и не провести нужные проверки во всех условиях, чтобы ни у кого не возникало проблем? Исчерпывающее тестирование — это как раз и есть тестирование, содержащее множество всех возможных проверок. Но и здесь стоит сделать существенное уточнение: Нет, не так. ВСЕХ ВОЗМОЖНЫХ проверок. Да, так лучше. Возьмем простой пример: у нас на сайте есть поле, в которое можно вводить только цифры и имеющее ограничение в 2 символа. Множество позитивных проверок составит ввод в поле значений от 0 до 99 плюс, возможно, еще некоторое количество проверок. Откуда этот плюс? Ну мы ведь не конкретизировали, отличается ли 1 от 01. Для ровного счета решим, что проверок будет 100 — от 0 до 99. Но мы упомянули, что это множество позитивных проверок, т.е. проверяющих, что поле делает то, что должно делать. Еще нужно убедиться, что поле не делает то, что оно делать не должно (то есть провести негативные проверки), верно? Раз сказано, что вводить можно только цифры, значит, все остальное вводить нельзя и при попытке ввести что-либо кроме цифры поле останется пустым. И привычных нам русских и английских букв не хватит. 

Мы ведь говорили о ВСЕХ ВОЗМОЖНЫХ проверках, следовательно, надо попробовать ввести в поле все буквы всех языков мира (поддерживаемые для ввода). Плюс знаки препинания, да. Дополнительно к этому еще все возможные для ввода спецсимволы, среди которых собака @, тильда ~ и т.д. и т.п.

Когда мы закончим с этим, мы выясним, что первый символ в поле точно не может быть ничем, кроме цифры. Но что, если в качестве второго символа поле может принять не цифру, а что-то другое? Нужно провести еще столько же проверок, вводя первым символом в поле цифру. От конкретной цифры тоже может что-то зависеть, например, «2а» нельзя ввести, а вот «3а» уже можно.

Кстати, регистр! Все буквы в качестве первого символа + 10 цифр в качестве первого символа во всех возможных сочетаниях со всеми буквами всех алфавитов + то же самое, но с буквами в верхнем регистре + все возможные для ввода спецсимволы в качестве первого символа + 10 цифр первым символом и всевозможные спецсимволы в качестве второго… мозги немножко свернулись в трубочку. А ведь мы проверяем маленькое поле, в которое можно всего-то две цифры ввести. Еще умножим это на все множество возможных версий всех возможных браузеров, в котором страница с этим полем открывается. Умноженное на множество всех возможных операционных систем, умноженное на множество всех возможных конфигураций компьютерного железа. А теперь оцените каких сотен триллионов миллиардов проверок потребует исчерпывающее тестирование страницы профиля пользователя, на которой надо заполнить имя, фамилию, дату рождения, e-mail и номер телефона.

Конечно, приведенный пример абсурден. Но он призван показать, насколько несостоятельна точка зрения «просто проведите все возможные проверки и багов не будет». На тестирование маленького поля с двумя цифрами вручную уйдет несколько человеческих жизней, а что говорить о приложении в вашем телефоне? О компьютерной игре, рассчитанной на 20 часов прохождения? Об операционной системе, в которой запускаются сотни или даже тысячи сторонних программ? 

**P.S.**

На практике тестировщики выбирают наиболее эффективные проверки, руководствуясь знаниями о тестируемом ПО и здравым смыслом. Например, если у нашего поля в коде задано ограничение на ввод только цифр, то с ввода цифр и следует начать (положительные проверки всегда идут первыми!). Для негативных проверок достаточно будет несколько раз ударить по клавишам в русской раскладке. Ну и на английской, для успокоения совести. Ничего не появилось — ок, буквы не принимает. Теперь спецсимволы — как правило, в таком случае просто копируется и вставляется строка в духе ``~@#$%^&*()_+|-=\{}[]:»;’<>?,./®©£¥¢¦§«»€`. Если что-то из этого не заблокировано, оно появится в поле. Плюс надо быть особенно внимательным к точкам и запятым, ведь ими может отделяться дробная часть, поэтому попробовать ввести «2,» и «5.» тоже стоит. Вот и все, мы ужали годы проверок в пять минут и отправились тестировать следующее поле, спасибо второму принципу тестирования.

<hr>

[Содержание](#содержание)

## Раннее тестирование

Пожалуй, самый осязаемый, самый материальный принцип. Как вы позже узнаете, процесс тестирования программного обеспечения включает в себя не только работу с уже готовым или скорее полуготовым продуктом. По сути своей, тестирование сопровождает процесс разработки где-то с момента зарождения идеи. Когда на каждую мысль «Вот так будет очень хорошо!» появляется критическая оценка «А правда ли будет?» — это уже можно назвать тестированием. Ну так, в глобальном, даже философском смысле. Тестировать же можно в принципе что угодно. Хотел прокатиться на ногах по замерзшей луже, а в итоге поскользнулся и упал — явное несовпадение ожидаемого результата с фактическим.

Но, возвращаясь к тестированию ПО, чем раньше была найдена ошибка (она же баг, она же дефект и т.д.), тем больше ресурсов будет сэкономлено. Ну или меньше потрачено, разницы нет. Под ресурсами мы понимаем, в первую очередь, время и деньги. Время — это тоже деньги, как известно. Да и вообще любые потери любой компании в конечном итоге можно измерить деньгами.

Предположим, команда собралась и обсудила фичу, которая планируется к разработке. По результатам обсуждения был написан документ, включающий описание этой самой фичи. Документ оказался проблемным, но никто его не вычитывал. Команда разработки создала и внедрила фичу на основании документа. Фича вышла в релиз. Выяснилось, что из-за новой фичи не работает половина старых. Куча гневных отзывов, сокращение количества пользователей (ушли к конкурентам). Потери компании колоссальны. Самое время уволить команду тестирования, если она вообще была. 

Это довольно мрачный сценарий, отмотаем немного назад. Команда тестирования была и, естественно, такую глобальную проблему отследила. Фича ушла на доработку, релиз был отложен, команда разработки потратила дополнительное время (ДЕНЬГИ!). Потери компании ощутимы. Ок, еще чуть назад. После написания документа он попал к тестировщикам, которые подробно изучили его и пришли к автору с замечаниями в духе «пункты 1-5 противоречат друг другу», «пункты 54 и 59 противоречат текущей реализации», «уточнить сколько именно означает «много» в пункте 118» и т.д. После устранения всех багов документа, фича была сделана в соответствии с ним и уже не повлекла разрушительных последствий при внедрении. Дополнительные затраты на исправление багов на уровне документации минимальны. Дешевле только сразу без ошибок написать, но в реальном мире так не бывает.

**P.S.**

Современные подходы говорят о том, что тестирование должно участвовать во всех этапах разработки ПО, а не просто получать на руки новую версию и протыкивать ее на предмет багов. Эффективность подобных практик доказана реальными результатами, поэтому в идеале команда тестирования должна быть на проекте уже на стадии первых обсуждений и планов. Скажу честно: нередко встречается устаревший взгляд на разработку, и тестировщики получают на руки уже готовые документацию (если она вообще есть) и версию продукта незадолго до релиза. Будьте морально к этому готовы.

**P.P.S А здесь у нас задание на воображение.**

Ну и на понимание материала, конечно. Попробуйте применить третий принцип тестирования к повседневной жизни. Приведите пример в комментарии, когда раннее обнаружение проблемы экономит ресурсы - в быту, на работе где угодно. Вот наш пример:

Больные зубы - это крайне неприятно. Но всё же многие идут к стоматологу даже не тогда, когда о проблеме становится известно (кусок зуба откололся), а только когда она начинает доставлять реальные неприятности, например, болит или окружающие обращают внимание. По итогу с запущенной проблемой всё равно приходится идти к врачу и тратить на лечение больше времени и денег по сравнению с более ранним визитом. А если (как и рекомендуется), начать посещать стоматолога раз в год вне зависимости от наличия известных проблем, то хотя бы часть этих самых проблем можно будет предотвратить, т.к. они будут найдены и устранены в зачаточном состоянии. То есть чем раньше найден баг (в зубах), чем больше экономия ресурсов - третий принцип тестирования в действии!

<hr>

[Содержание](#содержание)

## Бойтесь парадокса пестицидов!

Для того чтобы насекомые-вредители не ели урожай, растения обрабатывают химикатами (в том числе пестицидами). Речь как об огромных полях, на которые распыляют вещества с самолетов, так и о грядках на даче, которые опрыскивают, обмакивая веник в ведро с разведенным ядом. После первого применения большая часть насекомых умрет. Более того, состав останется на растениях и, если вдруг на освободившуюся кормовую базу нагрянут новые паразиты, жертвами яда падут и они. Но все же небольшая часть останется в живых. Почему? Ну, например, из-за индивидуальных особенностей конкретно вот этих самых особей. Им, скорее всего, будет очень плохо. Возможно, их жизнь даже будет более короткой и мучительной, чем у не отравленных собратьев. Но все же они успеют дать потомство, которое окажется чуть более невосприимчивым к яду. И так еще одно поколение, и еще одно. Прапрапра[много раз «пра»]внуки первых выживших будут поедать опрысканные растения также, как и неопрысканные. Возможно, без яда им уже будет не так вкусно, но это неточно. По итогу данный конкретный химикат перестанет действовать, а количество вредителей вернется к первоначальному уровню. Парадоксально, но применение пестицидов породило устойчивых к ним жуков. Эту проблему решают путем создания нового яда.

К чему это лирическое отступление об особенностях борьбы за урожай? Ну, разумеется, из-за аналогии «жуки — баги», как же обойти стороной такой грандиозный стереотип. И еще из-за того, что поведение ошибок в данном случае на редкость аналогично живым собратьям — они тоже подстраиваются под проверки, призванные их выявить (и уничтожить). Проверки становятся неэффективны, подобно пестицидам. Само собой, механизм совершенно другой и ничего общего с описанным в первом абзаце не имеет, но внешне похоже. И средство борьбы тоже очень похожее — при тестировании разных версий следует избегать одних и тех же тестовых данных, то есть применять, по сути, новый яд.

**P.S.**

Красиво звучит, а что на практике? А на практике возможна ситуация, когда программист, исправляя неоднократно найденный баг, изменит код таким образом, что баг на тех же самых данных перестанет повторяться, а на других продолжит. Предположим, в калькуляторе вместо умножения происходит сложение. Тестировщик всегда проверяет умножение, вводя 5х5 и получая 10 вместо 25. Тогда разработчик напишет код примерно такого содержания: если А=5 и В=5, то АхВ=25, во всех остальных случаях АхВ=А+В. В очередной раз введя 5х5, тестировщик наконец увидит 25 и подтвердит исправление бага. А если бы каждый раз вводил разное…

Разумеется, ни один вменяемый разработчик никогда не поступит подобным образом. Но на этом тривиальном примере очевидна нелогичность решения. В большой сложной системе может быть непонятно, что новый код не исправляет реальную проблему, а лишь делает ее менее заметной.

<hr>

[Содержание](#содержание)

## Кластеризация багов

> *Смотри-ка, альпинист с горы полетел! Второй, третий! Ого, да у них походу там гнездо!*

Закон Парето, столь любимый маркетологами и разного рода инфоцыганами, справедлив и для дефектов ПО. Это тот, который про 20% одного дает 80% другого. В нашем случае одним является функционал, а другим — баги. Ошибки при проверках имеют свойство складываться вместе, образовывая кластер. Или кучковаться в одном кластере разрабатываемого ПО — суть не меняется. 

Почему так получается? Причин может быть много, одно тянет за собой другое, а каждый случай индивидуален. Например, за «проблемный» модуль продукта отвечает программист, который ранее с подобными задачами не сталкивался. Учится по ходу дела и допускает много ошибок при выполнении задач. Или у заказчика нет четкого понимания как эта часть программы должна работать, он пытается менять решения на ходу, что сильно сказывается на уже сделанных частях. Или модуль плохо описан в документации, из-за чего возникает множество разночтений при выполнении. 

Докопаться до первопричины, устранить сразу множество имеющихся багов или хотя бы предотвратить появление будущих — это очень здорово. Но редко когда удается это сделать. Если разработчик только набирается опыта, он не наберется его моментально. На заказчика не снизойдет ясное видение готового продукта. А документация не изменится в одночасье. 

Для нас, как тестировщиков, важен один вывод из пятого принципа: нашел баг — поищи другой поблизости.

**P.S.**

Немного о другом, но все же важном на практике моменте. Согласно принципам программирования, похожие элементы не создаются каждый по отдельности. Вместо этого общая часть кода пишется в одном месте и используется уже в коде однотипных элементов в виде ссылки, а разнящиеся части дописываются после нее. Таким образом, если баг вызван ошибкой в общей части кода, сломаются все использующие общий код элементы. И, будучи найденным в одном элементе, этот баг может быть пропущен в другом. Об этом тоже надо помнить и сразу оценивать, что еще мог зацепить найденный баг.

**Дисклеймер:** знающие хоть что-то о программировании люди, простите нас за такие формулировки. В данном случае было важно объяснить принцип тем, кто вообще не представляет себе как оно устроено.

<hr>

[Содержание](#содержание)

## Тестирование зависит от контекста

> *Вася, не грызи ногти! На ногах. У дедушки. И вообще отойди от гроба.*

Справедливости ради, вообще все в нашей жизни зависит от контекста. Убийство врага на войне и убийство случайного прохожего ради его кошелька отличаются друг от друга как с моральной стороны, так и со стороны уголовного права. Шутка, уместная в компании близких друзей совершенно необязательно так же здорово прозвучит среди коллег на работе. За песни и пляски в церкви можно заиметь неиллюзорных проблем, но только если церковь не афроамериканская, там проблемы возникнут в обратном случае. Одно и то же действие может быть трактовано окружающими очень по-разному в зависимости от обстоятельств, которые этому действию сопутствуют.

Но мы же о тестировании, так что давайте приведем пример из ПО. Как вы думаете, где нужно уделить больше времени тестированию безопасности, в банковском мобильном приложении или в приложении, показывающем скидки в ближайших магазинах? Какой веб-сервис должен быть максимально «вылизан» в плане дизайна и удобства пользователя — интернет-магазин или онлайн система учета медицинских анализов? Надежность какой операционной системы должна быть протестирована лучше — устанавливаемой на автомобили Tesla или Windows Home Edition?

Если эти вопросы пока вызывают у вас сомнения, то ничего страшного. Это только от того, что шестой принцип тестирования еще недостаточно вами постигнут. Рассмотрим ответы подробно. Безопасность банковского приложения подразумевает, что злоумышленник не сможет получить доступ к деньгам пользователя. Вряд ли приложение со скидками может обеспечить такой же уровень риска — его можно менее тщательно протестировать с точки зрения безопасности. Интернет-магазин заинтересован в том, чтобы к нему шли клиенты, поэтому он должен быть красивым и максимально удобным. Система учета медицинских анализов — профессиональное ПО, люди используют его ради функционала и любые «украшательства» могут сыграть только в минус. Частью удобства также можно пожертвовать, если компенсировать ее расширенным функционалом. Наконец, цена отказа операционной системы, установленной на домашнем компьютере — потеря данных с последующей перезагрузкой, что доставит много неприятных эмоций пользователю. Цена отказа ОС автомобиля — человеческие жизни. 

**P.S.**

Только не подумайте, что выбор в ответе одной системы подразумевает отсутствие тестирования в другой. Написанное выше НЕ значит, что у приложения со скидками вообще не надо тестировать безопасность. НЕ значит, что профессиональная система будет иметь вырвиглазный дизайн и окажется абсолютно неудобной в применении. А Windows будет падать каждые пять минут и это будет вполне нормально. Тут, пожалуй, уместна такая аналогия: спортсмен, готовящийся к соревнованиям, занимается спортом 6 часов в день. Офисный работник, заботящийся о своем здоровье, занимается спортом 6 часов в неделю. Все решают приоритеты, определяемые глобальными и текущими задачами, т.е. тот самый контекст.

<hr>

[Содержание](#содержание)

## Заблуждение об отсутствии багов

Для начала вспомним первые два принципа тестирования: невозможно доказать отсутствие багов в системе и провести исчерпывающее тестирование. Таким образом, заблуждение об отсутствии багов состоит в том, что отсутствие багов вообще возможно. Но это только первый момент, ненадолго забудем о нем и копнем чуть глубже.

Допустим, отсутствие багов возможно. Надо ли к нему стремиться? Единственное ПО, которое не глючит! Да, хорошее конкурентное преимущество, вот только способно ли оно обеспечить успех нашему ПО? А если идея, заложенная в основу, никому не нужна? Если задачи, которые призвано решать наше ПО, можно решить быстрее и проще без него? Или вовсе можно проигнорировать? Иными словами, само по себе отсутствие багов не может гарантировать востребованность продукта.

Ну мы же не дураки, мы не будем делать ставку только на отсутствие багов, верно? У нас отличная идея, наш продукт действительно решает насущные проблемы и упрощает жизнь пользователям. А отсутствие багов — это просто преимущество, одно из многих. Успех? Вполне очевидно, что тестирование такого продукта потребует больше временных и финансовых затрат по сравнению с конкурентами (у них же баги есть). Лишняя трата денег может в итоге отразиться на цене продукта. Высокая цена резко снизит его привлекательность. Да, у конкурента есть небольшие баги, но они не мешают работе и продукт при этом в два раза дешевле. Дополнительные временные затраты еще страшнее — пока мы доводили до идеала первую версию, конкуренты уже собрали отзывы и пожелания пользователей, на их основании выпустили вторую версию, исправили ее недоработки в третьей, обкатали новый функционал в четвертой, довели его до удобства в пятой и планируют еще набор фич в шестой. По итогу наш продукт рядом с их продуктом выглядит примерно как «Жигули» рядом с «Мерседесом». Вроде бы и то, и другое едет, но пользователи предпочитают второе. Вспомним про дополнительные денежные траты на достижение результата, поменяем ценники у «Жигулей» и «Мерседеса» местами — станет совсем грустно.

Вернемся в реальность. Отсутствие багов невозможно, но это мы знали и раньше, так о чем же седьмой принцип? Он о том, что отсутствие багов не смогло бы обеспечить серьезных преимуществ. Не надо бояться самого факта наличия багов в системе, баги — это нормально.

**P.S.**

И это опять-таки не значит, что тестировщик не несет ответственности за пропущенный баг, а на любые претензии может ответить «Баги — это нормально». Действительно, пропущенный краш приложения, повторяющийся при смене языка у 0,001% пользователей, это не так уж и страшно. Пропущенный краш приложения при запуске, повторяющийся у 99% пользователей — свидетельство того, что приложение никто не тестировал. Если хорошо поискать, баги найдутся в любом ПО, но очень важно, чтобы эти баги не мешали (ну хотя бы несильно) большинству пользователей.

<hr>

[Содержание](#содержание)

# 2.7 Пирамида тестирования

[Видео-шпаргалка урока "Пирамида тестирования"](https://youtu.be/0fLMcTbEStg)

![02](/TestingBegin/img/02_08.png)

Выделяют четыре уровня тестирования:
+ Модульное тестирование (Component/Unit testing) - это уровень тестирования, на котором отдельные компоненты или модули программного продукта проверяются независимо от других частей системы. 
+ Интеграционное тестирование (Integration testing) - на этом уровне тестируется взаимодействие между различными компонентами или модулями системы.
+ Системное тестирование (System testing) - это тестирование всей системы в целом. 
+ Приемочное тестирование (Acceptance testing) - на этом уровне проверяется соответствие системы требованиям и ожиданиям заказчика или конечного пользователя. 

Задачи любого уровня тестирования включают:

+ Снижение риска: тестирование помогает выявить потенциальные проблемы и риски, связанные с работой системы, и предотвратить их возникновение в процессе эксплуатации.
+ Обнаружение дефектов: основная задача тестирования - выявить ошибки, дефекты и неполадки в работе системы, чтобы разработчики могли их исправить перед выпуском продукта.
+ Предотвращение перехода дефектов на более высокие уровни: тестирование на разных уровнях позволяет выявить дефекты на ранних стадиях разработки и предотвратить их распространение на более высокие уровни системы, где исправление ошибок может быть более сложным и затратным.

<hr>

[Содержание](#содержание)

## Модульное тестирование

Модульное тестирование, также известное как юнит-тестирование или компонентное тестирование, является важной частью процесса проверки программного кода. Оно проводится для проверки отдельных модулей или компонентов кода с целью убедиться, что они работают правильно в соответствии с требованиями и спецификациями.

Модульное тестирование обычно выполняется разработчиками с использованием специализированных фреймворков и инструментов для тестирования. Каждый модуль тестируется отдельно, чтобы убедиться, что он ведет себя правильно и возвращает ожидаемые результаты. Это может быть проверка отдельной веб-страницы, функции, объекта или класса в приложении.

Например, если у нас есть две страницы в приложении - страница регистрации и страница авторизации, модульное тестирование будет проверять, что каждая страница работает корректно отдельно. Например, на странице регистрации можно успешно зарегистрировать нового пользователя, а на странице авторизации можно успешно войти под уже зарегистрированным пользователем.

Ошибки, найденные в процессе модульного тестирования, обычно исправляются самими разработчиками без создания отчетов о багах в системе отслеживания ошибок.

Типичные дефекты, выявляемые при модульном тестировании, могут включать:

+ Неправильное поведение модуля, которое не соответствует требованиям и документации.
+ Ошибки в коде, такие как неправильные вычисления, неправильное использование переменных или неправильная обработка исключительных ситуаций.

Модульное тестирование позволяет выявить и исправить ошибки на ранних этапах разработки, улучшая качество и надежность программного продукта.

<hr>

[Содержание](#содержание)

## Интеграционное тестирование

Интеграционное тестирование является процессом проверки взаимодействия между модулями системы или несколькими системами. Поскольку разные модули могут быть разработаны разными программистами, важно проверить корректность и надежность их взаимодействия.

В интеграционном тестировании один компонент или модуль генерирует выходные данные, которые затем передаются другому компоненту в качестве входных данных. Целью этого тестирования является проверка того, что все смежные системы и модули работают в согласованном режиме.

Например, при тестировании интеграции веб-приложения с платежной системой, проверяется правильность перехода со страницы корзины на страницу платежной системы и успешное осуществление оплаты.

Типичные объекты тестирования включают подсистемы, базы данных, интерфейсы взаимодействия системы и микросервисы. 

При проведении интеграционного тестирования могут быть обнаружены следующие типичные дефекты:

+ Отсутствие или неправильные данные, передаваемые между компонентами.
+ Сбои в связи или передаче данных между компонентами.
+ Нарушение обязательных правил безопасности при передаче данных между системами.

Интеграционное тестирование позволяет убедиться в правильном взаимодействии различных компонентов системы и обеспечить их согласованную работу для достижения целостности и функциональности системы в целом.

<hr>

[Содержание](#содержание)

## Системное тестирование (System testing)

Системное тестирование (System testing) выполняется после завершения интеграционного тестирования. На этом этапе разработчики создают и тестируют модули, а затем интегрируют их между собой, чтобы получить полноценную систему или базовую модель приложения.

Основная цель системного тестирования заключается в проверке функциональности всего приложения в целом.

На уровне системного тестирования проводится проверка полного пути использования продукта, также известного как end-to-end (E2E) flow. Путь использования охватывает всю последовательность действий от запуска приложения до достижения конечного результата.

Например, для интернет-магазина сценарий end-to-end может выглядеть следующим образом:

1. Незарегистрированный пользователь переходит на сайт интернет-магазина.
2. Регистрируется на сайте.
3. Авторизуется на сайте.
4. Находит необходимый товар.
5. Добавляет товар в корзину.
6. Статус заказа устанавливается как "Ожидает оплаты".
7. Оплачивает заказ.
8. Деньги поступают на счет компании.
9. Статус заказа меняется на "Оплачен".
10. После получения заказа пользователем статус заказа меняется на "Получен".

При системном тестировании могут быть обнаружены следующие типичные дефекты:

+ Неожиданное или неправильное поведение системы.
+ Неспособность системы выполнить end-to-end задачи.
+ Неспособность системы правильно функционировать в различных средах.
+ Несоответствие работы системы инструкциям пользователя.

Системное тестирование позволяет удостовериться в корректности работы всей системы, ее способности выполнять задачи end-to-end и соответствии функционирования системы требованиям и ожиданиям пользователей.

<hr>

[Содержание](#содержание)

## Приемочное тестирование (Acceptance testing)

Приемочное тестирование (Acceptance testing) проверяет, выполнены ли все бизнес-требования перед выпуском приложения на рынок. Этот этап тестирования является завершающим и проводится после модульного, интеграционного и системного тестирования.

Одним из ключевых аспектов приемочного тестирования является использование реальных данных и реальных сценариев использования приложения. Такой подход делает этот этап тестирования критическим в рамках процесса выпуска приложения. Приемочное тестирование выполняется с целью убедиться, что приложение соответствует критериям приемки, которые определены заказчиком.

Приемочное тестирование включает различные формы:

1. Пользовательское приемочное тестирование (User acceptance testing) - проводится конечными пользователями продукта. В этом случае пользователи проверяют приложение на соответствие их требованиям и ожиданиям.

2. Операционные приемочные испытания (Operational acceptance testing) - проводятся системными администраторами. Они проверяют функции резервного копирования, установки/удаления/обновления системы, а также проверяют безопасность и производительность приложения. Целью этого типа тестирования является убеждение, что приложение можно обслуживать и сопровождать на необходимом уровне, даже в экстремальных условиях.

3. Контрактные и нормативные приемочные испытания (Contractual and regulatory acceptance testing) - проверка того, что приложение соответствует всем нормативным требованиям, не нарушает интеллектуальную собственность других лиц и не использует нелицензионное программное обеспечение.

4. Альфа и бета-тестирование (Alpha and beta testing):

+ Альфа-тестирование включает имитацию реального использования продукта со стороны внутренних или внешних разработчиков, а также команды тестировщиков.
+ Бета-тестирование проводится реальными пользователями с целью получения обратной связи и выявления максимального числа ошибок перед окончательным выпуском продукта на рынок (релизом).

Например, известная компания "WarGaming" использует несколько групп тестирования:

+ Отдел тестирования WarGaming, состоящий из сотрудников компании, занимается большей частью тестирования продуктов. От них зависит качество популярных танковых игр компании.
+ Участники "Супертест" - группа опытных игроков, которые помогают разработчикам собирать статистику, оставлять комментарии и предложения, а также обнаруживать неочевидные ошибки.

Легко догадаться, что отдел тестирования проводит альфа-тестирование, а "Супертест" участвует в бета-тестировании.

**Ключевые различия между UAT и бета-тестированием**

+ UAT проводится в контролируемой среде. Бета-тестирование проводится в реальных условиях.
+ UAT обычно выполняется клиентом. Бета-тестирование проводится конечным пользователем.
+ UAT выполняется одним или двумя пользователями. Бета-тестирование может проводиться сотнями или тысячами.
+ UAT предназначен для проверки бизнес-требований. Бета-тестирование предназначено для сбора отзывов об удобстве использования с целью улучшения продукта для основного выпуска.
+ UAT часто предполагает работу вместе с командой тестирования и/или разработки. Бета-тестирование проводится только конечным пользователем.
+ UAT является продолжением этапа разработки. Бета-тестирование проводится непосредственно перед финальным выпуском.

<hr>

[Содержание](#содержание)

# 2.8 Виды тестирования по доступу к коду

[Видео-шпаргалка урока "Виды тестирования по доступу к коду"](https://youtu.be/xpwW0KAjI9s)

>**ISTQB (International Software Testing Qualifications Board)** - это международная организация, занимающаяся сертификацией тестирования программного обеспечения.

Тестирование белого, черного и серого ящиков (white, black, and grey box testing) относится к видам тестирования, направленным на определение доступа к внутренней системе программного обеспечения. В зависимости от наличия доступа к коду, тестирование может быть проведено как с использованием знания о внутренней структуре ПО, так и без такого знания.

<hr>

[Содержание](#содержание)

## Тестирование черного ящика (black box testing)

**Тестирование черного ящика (black box testing)** - это техника тестирования, основанная на работе исключительно с внешними интерфейсами системы, при отсутствии доступа к коду.

Согласно ISTQB, тестирование черного ящика включает:

+ Тестирование функциональных и нефункциональных аспектов системы, не требующее знания внутреннего устройства компонента или системы.
+ Тест-дизайн, основанный на технике черного ящика, включающий написание или выбор тест-кейсов на основе анализа функциональной или нефункциональной спецификации компонента или системы без знания ее внутреннего устройства.

**Преимущества черного ящика:**

+ Тестирование выполняется с точки зрения конечного пользователя и может помочь выявить неточности и противоречия в спецификации.
+ Тестировщикам не требуется дополнительные знания программирования.
+ Можно начинать разработку тест-кейсов сразу после завершения спецификации.

**Недостатки черного ящика:**

+ Тестируется только ограниченное количество путей выполнения программы.
+ Без четкой спецификации может быть сложно разработать эффективные тест-кейсы.
+ Некоторые тесты могут оказаться избыточными, если разработчик уже проводил их на уровне модульного тестирования.

Примером черного ящика может служить тестирование обычного калькулятора. В данном случае у тестировщика нет доступа к внутренней системе, но он может предположить, как пользователь будет использовать калькулятор, и на основе этого проводить тестирование функций, таких как отображение цифр при нажатии на кнопки, работа операторов (сложение, вычитание и т.д.), удаление результата и т.д.

<hr>

[Содержание](#содержание)

## Тестирование белого ящика (white box testing)

**Тестирование белого ящика (white box testing)** - это вид тестирования программного обеспечения, при котором тестировщику известна внутренняя структура, устройство и реализация системы, а также есть полный доступ к коду, включая возможность самостоятельно писать код.

При тестировании белого ящика мы выбираем входные значения и проектируем тесты, исходя из знания внутренней логики и алгоритмов обработки данных. Мы имеем представление о том, как программа должна обрабатывать данные и какой ожидается результат.

Обычно программисты занимаются тестированием белого ящика на проектах, так как для этого вида тестирования требуется высокая квалификация.

Согласно ISTQB, тестирование белого ящика включает:

+ Тестирование, основанное на анализе внутренней структуры компонента или системы.
+ Тест-дизайн, основанный на технике белого ящика, включающий написание или выбор тест-кейсов на основе анализа внутреннего устройства системы или компонента.

Преимущества тестирования белого ящика:

+ Тестирование может быть выполнено на ранних этапах разработки, без необходимости ожидания создания пользовательского интерфейса.
+ Возможность проведения более тщательного тестирования с покрытием большего количества путей выполнения программы.

Недостатки тестирования белого ящика:

+ Для выполнения тестирования белого ящика требуется обладать глубокими знаниями и опытом в программировании и анализе кода.
+ Упор делается на аспекты кода, без учета позиции конечного пользователя, что может приводить к упущению некоторых ошибок.

Примером белого ящика может служить тестирование двигателя автомобиля. Для водителя, особенно начинающего, двигатель автомобиля является черным ящиком. Однако для механика, который имеет знания о внутренней структуре и работе компонентов двигателя, он становится белым ящиком. Механик, подобно программисту, понимает логику работы компонентов двигателя и знает его слабые места, что помогает ему проводить более точное и глубокое тестирование.

<hr>

[Содержание](#содержание)

## Тестирование серого ящика (grey box testing)

**Тестирование серого ящика (grey box testing)** - это вид тестирования программного обеспечения, который сочетает подходы тестирования белого и черного ящиков. При таком виде тестирования у тестировщика есть частичный доступ к коду и знание внутреннего устройства программы, но не настолько полное, как при белом ящике.

Преимущества тестирования серого ящика:

+ Включает в себя преимущества и подходы тестирования черного и белого ящиков. Тестировщик рассматривает объект тестирования с позиции черного ящика, но при этом может использовать информацию о системе, которую он знает.
+ Позволяет проектировать и использовать более сложные сценарии тестирования.
+ Дает разработчику достаточно времени для исправления дефектов.

Недостатки тестирования серого ящика:

+ Возможность анализа кода и покрытия тестами ограничена из-за частичного доступа к исходному коду.
+ Некоторые тесты могут оказаться избыточными, особенно если разработчик уже проверил свой код с помощью модульных тестов.

Примером серого ящика может служить ситуация, когда разработчик проверяет программу с помощью тестирования черного ящика, либо когда тестировщик, ознакомившись с архитектурой программы, проверяет ее также с использованием тестирования черного ящика. Оба понимают логику работы программы, но оценивают ее с точки зрения пользователя.

Отметим, что ISTQB не распознает "средний" или "промежуточный" вид тестирования в контексте серого ящика. В классификации ISTQB мы разрабатываем тесты, либо зная код, либо не зная его.

<hr>

[Содержание](#содержание)

# 2.9 Виды тестирования по формализации подхода к тестированию

[Видео-шпаргалка урока "Виды тестирования по формализации подхода к тестированию"](https://youtu.be/vJM9SSq8mQg)

Рассмотрим подходы к тестированию по степени формализации:

>**Формальность** —  это «иметь общепризнанную форму, структуру или набор правил».

1.  **Тестирование на основе тест-кейсов (виды тестовой документации будут рассмотрены в 3 разделе курса)** — формализованный подход, в котором тестирование производится на основе заранее подготовленных тест-кейсов  и иной документации.

Тест-кейс — это совокупность входных данных, условий выполнения и ожидаемого результата, необходимых для проверки реализации функционала тестируемого программного обеспечения (ПО) или какого-то его свойства.

Эта информация включает в себя четкое описание действий, которые нужно выполнить, шаг за шагом. После выполнения действий нужно сравнить ожидаемый результат работы приложения с тем, который получен.

Это самый распространенный способ тестирования, который также позволяет достичь максимальной полноты исследования продукта за счет строгой систематизации процесса.

2.  **Исследовательское тестирование (Exploratory testing)** — это частично формализованный подход тестирования ПО, при котором тестовые наборы не создаются заранее, а тестировщик проверяет приложение «на лету».

Тестировщик выполняет работу с продуктом по выбранному сценарию, который, в свою очередь, дорабатывается в процессе выполнения с целью более полного исследования приложения.

Исследовательское тестирование ориентировано больше на тестирование как на мыслительную деятельность, а не как на бездумное воспроизведение по заранее написанному сценарию. При тестировании по сценарию ты сначала разрабатываешь тестовые случаи, а затем исполняешь их. Исследовательское тестирование — это одновременный процесс разработки и выполнения тестов.

В качестве альтернативы сценариям при выборе действий с приложением иногда могут использоваться чек-листы.

Также в результате исследовательского тестирования могут появиться новые тест-кейсы. То есть мы можем выполнять исследовательское тестирование и с целью написания новых тест-кейсов.

3.  **Свободное (интуитивное) тестирование (Ad Hoc Testing или Monkey Testing)** полностью неформализованный подход, в котором не предполагается использования ни тест-кейсов, ни чек-листов, ни сценариев.

Тестировщик полностью опирается на свою интуицию для спонтанного выполнения с продуктом действий, которые, как он считает, могут обнаружить ошибку.

В прямом смысле — «куда хочу, туда и кликаю, в порядке каком хочу».

Такое тестирование не требует никакой документации, планирования, наличия процессов, которых следует придерживаться при выполнении тестирования. Таким образом, метод не структурирован, и, следовательно, дефекты, обнаруженные с помощью этого метода, может быть труднее воспроизвести, но и вместе с этим возможно найти «Хитрые баги».

В свою очередь Интуитивное тестирование подразделяется на 2 вида:

+ `buddy testing` (совместное тестирование) — когда 2 человека, как правило разработчик + тестировщик, работают параллельно и находят дефекты в одном и том же модуле. Такой вид тестирования помогает тестировщику выполнять необходимые проверки, а программисту фиксить баги на ранних этапах.

+ `pair testing` (парное тестирование) —  когда 2 тестировщика проверяют один модуль и помогают друг другу. К примеру, один может искать дефекты, а второй —  их документировать.

Используя различные подходы к тестированию, можно выбирать один или комбинацию подходов, для более глубокого и обширного тестирования. Какой именно подход выбирать — зависит от конкретного проекта и целей поставленных перед тестировщиком.

<hr>

[Содержание](#содержание)

# 2.10 Виды тестирования по критерию запуска программы

[Видео-шпаргалка урока "Виды тестирования по критерию запуска программы"](https://youtu.be/X144_fb6HIk)

По критерию запуска программы тестирование делится на два типа: Статическое и Динамическое.

**Статическое тестирование (Static Testing)** — это вид тестирования, при котором код программы не исполняется во время проведения тестов. Оно включает в себя тестирование спецификаций, документации, файлов, а также анализ программного кода (code review) или скомпилированного кода без его запуска. Статическое тестирование может быть выполнено как вручную, так и с использованием специальных инструментальных средств, автоматизированно.

Code review (код-ревью) может проводиться одним из участников команды разработчиков или тестировщиком. Обычно на код-ревью проверяются качество кода, соблюдение стандартов использования, решения реализации, и оставляются комментарии. Это помогает предотвратить дефекты на ранних этапах разработки.

**Динамическое  тестирование (Dynamic Testing)** — это тестирование, при котором код программы выполняется, и проверяется поведение приложения во время его работы. В динамическом тестировании происходит взаимодействие с интерфейсом запущенной программы, ее формами, сервером, базой данных и другими компонентами.

Если проводятся тесты на работающем приложении — значит, это динамические тесты.

<hr>

[Содержание](#содержание)

# 2.11 Виды тестирования по степени автоматизации

[Видео-шпаргалка урока "Виды тестирования по степени автоматизации"](https://youtu.be/2bv-tQdkjuw)

По степени автоматизации тестирование делится на Ручное и Автоматизированное.

**Ручное тестирование (Manual Testing)** - это вид тестирования, при котором тестировщики вручную выполняют тесты без использования инструментов автоматизации. Каждое приложение должно быть протестировано вручную, прежде чем тесты можно будет автоматизировать. Ручное тестирование позволяет выявить проблемы, которые могут быть упущены при автоматическом тестировании. Оно не требует особых навыков использования инструментов и является неотъемлемой частью любого проекта. Один из основных принципов тестирования заключается в том, что 100% автоматизация невозможна. 

**Автоматизированное тестирование (Automated Testing)** - это вид тестирования, при котором тесты проводятся автоматически с помощью специальных инструментов. Например, для веб-приложений часто используется инструмент Selenium, а для мобильных приложений - Appium. При автоматизированном тестировании тесты выполняются без прямого участия человека. Это позволяет ускорить процесс тестирования и повысить его эффективность. Главная цель автоматизации - сократить количество тестов, которые необходимо выполнять вручную, и таким образом сэкономить время на тестирование.

Оба подхода имеют свои преимущества и ограничения, и выбор между ними зависит от конкретного проекта, его требований и доступных ресурсов. Часто используется комбинация ручного и автоматизированного тестирования для достижения оптимальных результатов.

<hr>

[Содержание](#содержание)

# 2.12 Виды тестирования по ожидаемому поведению системы

[Видео-шпаргалка урока "Виды тестирования по ожидаемому поведению системы"](https://youtu.be/hFAh9nL2qM0)

По ожидаемому поведению тестирование разделяется на:

+ **​​​​​​​Позитивное тестирование (Positive Testing)** - это тестирование, при котором используются сценарии, соответствующие ожидаемому поведению приложения.<br>
Позитивные тестовые сценарии проверяют, что приложение работает в соответствии с требованиями, когда пользователь предоставляет допустимые и валидные данные или выполняет предусмотренные действия.<br>
Например, позитивный сценарий для процесса авторизации в системе может включать ввод существующего логина, правильного пароля и нажатие кнопки "Войти". Ожидаемый результат - успешная аутентификация и вход в систему.

+ **Негативное тестирование (Negative Testing)** - это тестирование, при котором используются сценарии, соответствующие некорректному поведению или внештатным ситуациям приложения.<br>
Негативные тестовые сценарии проверяют, как приложение обрабатывает данные, которые выходят за границы, определенные требованиями, или неожиданные действия пользователей.<br>
Например, негативный сценарий для процесса авторизации в системе может включать ввод несуществующего логина или неправильного пароля, а затем нажатие кнопки "Войти". Ожидаемый результат - появление сообщения об ошибке или неправильности введенных данных.

Использование как позитивного, так и негативного тестирования важно для обеспечения полного охвата функциональности приложения и выявления потенциальных проблем или ошибок, которые могут возникнуть в различных ситуациях использования.

<hr>

[Содержание](#содержание)

# 2.13 Виды тестирования по изменению кода

[Видео-шпаргалка урока "Виды тестирования по изменению кода"](https://youtu.be/_RxKLx5C9nU)

В проекте всегда происходят изменения, так как функциональность приложения обновляется, улучшается и расширяется. Каждое изменение в коде может потенциально вызвать ошибки, поэтому необходимо проверить все внесенные изменения. Рассмотрим несколько видов тестирования, которые помогут в этом.

**Дымовое тестирование (Smoke Testing)** включает выполнение минимального набора тестов на самые очевидные ошибки. Оно проверяет работоспособность критически важных функциональных частей приложения.

Например, это может быть проверка регистрации нового пользователя, создание нового заказа, выставление счета клиенту или получение оплаты. Дымовое тестирование фокусируется на базовой функциональности, которая должна быть регулярно контролируема через такие тесты.

**Санитарное тестирование (Sanity Testing)** проводится после незначительных изменений в функциональности, коде или исправлении ошибок. Его целью является проверка того, что исправленный код или новая функциональность работают, как ожидалось.

Например, если программисты устранили ошибку на странице создания нового заказа, санитарные тесты должны проверить общее состояние приложения и убедиться, что изменения не вызвали новые проблемы. Обычно санитарное тестирование выполняется вручную.

**Регрессионное тестирование (Regression Testing)** направлено на обнаружение ошибок в уже проверенных участках программы или исходном коде. Оно помогает убедиться, что недавние изменения не повлияли на работу уже функционирующей функциональности приложения. Регрессионное тестирование должно проводиться при любых изменениях кода, и полная автоматизация является лучшей практикой для этого вида тестирования. В регрессию включаются тесты, которые покрывают тестирование безопасности, критических и важных функций. Включаются те области, которые часто меняются в ходе разработки, где высока вероятность ошибки.

Например, после внесения исправлений в систему оплаты онлайн-магазина, регрессионное тестирование может включать проверку всех ранее протестированных функций, таких как добавление товаров в корзину, оформление заказа и процесс оплаты, чтобы убедиться, что внесенные изменения не повлияли на их работу и функциональность.

**Повторное тестирование (Retesting)** проводится после исправления ошибки в части функциональности для подтверждения исправления. Оно повторно проверяет и подтверждает, что ранее неуспешные тест-кейсы успешно проходят после устранения ошибки.

Например, если была обнаружена ошибка в функции отправки электронной почты, после ее исправления проводится повторное тестирование, чтобы убедиться, что тест-кейсы, которые ранее не проходили успешно из-за этой ошибки, теперь успешно проходятся и функциональность работает корректно.

Использование различных методов тестирования, таких как дымовое, санитарное, регрессионное и повторное тестирование, помогает обеспечить качество приложения и выявить возможные проблемы после внесенных изменений. Комбинирование автоматизированных и ручных подходов может быть эффективным для достижения оптимального покрытия тестами.

<hr>

[Содержание](#содержание)

# 2.14 Виды тестирования в зависимости от цели

[Видео-шпаргалка урока "Виды тестирования в зависимости от цели"](https://youtu.be/KfQ-ngzBiRU)

Тестирование в зависимости от цели делится на Функциональное тестирование и Нефункциональное тестирование.

**Функциональное тестирование (Functional Testing)** - это вид тестирования, который проверяет функции приложения и его способность выполнять задачи. Оно включает в себя различные типы тестов, такие как модульное, интеграционное, системное и приемочное тестирование. Регрессионное и дымовое тестирование также относятся к функциональному тестированию. В процессе функционального тестирования используются требования в форме спецификаций или пользовательских историй.

**Нефункциональное тестирование (Non-functional Testing)**, в свою очередь, оценивает характеристики системы или программного обеспечения, такие как надежность, производительность, удобство использования, эффективность работы и безопасность. Оно проверяет, насколько хорошо система справляется с этими характеристиками.

Рассмотрим Нефункциональное тестирование подробнее:

+ **Тестирование пользовательского интерфейса (User interface testing)** — проверка соответствия интерфейса ПО требованиям дизайна. Например, проверка наличия всех требуемых элементов на странице, их размеров и расположения, тестирование шрифтов, цветов, изображений.

+ **Тестирование удобства пользования (Usability Testing)** — определение удобства использования приложения. Проверяется эргономичность интерфейсов. Например, оформление и графические элементы с точки зрения удобства восприятия, удобство навигации. В этот вид входит Тестирование доступности.

+ **Тестирование Доступности (Accessibility Testing)** — проверка доступности приложения для пользователей с нарушением слуха, зрения и цветовосприятия, а также людей, у которых нет возможности использовать клавиатуру. Например, использование определенной цветовой гаммы, добавление субтитров на видео или озвучивание всей страницы.

+ **Тестирование производительности (Performance Testing)** фокусируется на проверке скорости, отзывчивости и эффективности системы в различных условиях. Например, мы рассчитываем, что одновременно приложением будет пользоваться 500 пользователей, и через специальные программы создаются условия для измерения времени, необходимого для выполнения определенных операций.

+ **Нагрузочное тестирование (Load testing)** заключается в проверке системы при различных нагрузках, чтобы определить ее поведение и работоспособность в условиях максимального или предельного использования. Например, мы рассчитываем, что одновременно приложением будет пользоваться 500 пользователей, и через специальные программы создаются условия, которые моделируют нарастающее использование приложения до 500 пользователей.

+ **Стресс-тестирование (Stress testing)** — используется для определения устойчивости системы или модуля при пороговых значениях рабочей нагрузки или за ее пределом. К примеру моделируются условия одновременного использования 500 или немногим более пользователей.

+ **Объемное тестирование (Volume testing)** — тестирование позволяет оценить производительность системы при увеличении объемов данных как самого приложения, так и его базы данных. Когда те же 500 пользователей отправляют одновременно какой-то объем информации.

+ **Тестирование надежности  (Reliability Testing)** — проверка работоспособности приложения при длительном тестировании с ожидаемым уровнем нагрузки.

+ **Тестирование безопасности (Security Testing)** — оценка уязвимости приложения к различным атакам. Оценка безопасности пользовательских данных, на сколько просто неавторизованный пользователь может получить доступ к системе или данным.

+ **Тестирование установки (Installation Testing)** — проверка успешной инсталляции, настройки, обновления и удаления.

+ **Тестирование совместимости (Compatibility Testing)** — проверка корректной работы приложения в определенном окружении, например, устройстве, операционной системе (кроссплатформенное тестирование) или браузере (кроссбраузерное тестирование).

+ **Тестирование на отказ и восстановление (Recovery Testing)** — проверка насколько хорошо приложение может оправиться от аварий и сбоев оборудования.

+ **Тестирование локализации (Localization Testing, l10n)** — тестирования локализованной версии приложения: проверка правильности перевода интерфейса пользователя, системных сообщений и ошибок, раздела "Помощь"/"Справка",  документации, контроль формата даты и времени.

+ **Тестирование интернационализации (Internationalization Testing, i18n)** — Насколько продукт может адаптироваться для той или иной локали при выходе на другие рынки. Например, возможность поддержки вертикального текста Азиатских стран, чтение справа налево в арабских странах.

**В целом, можно сказать, что нет строгой системы распределения по видам и типам тестирования. Есть «скелет», а остальные виды могут мигрировать.**

<hr>

[Содержание](#содержание)