# 4. Планета тест-дизайна

## Содержание

+ [4.1 Планета тест-дизайна](#41-планета-тест-дизайна)
+ [4.2 Зачем "дизайн" тестировщику?](#42-зачем-дизайн-тестировщику)
    + [Что такое тест дизайн?](#что-такое-тест-дизайн)
+ [4.3 Классы эквивалентности и граничные значения](#43-классы-эквивалентности-и-граничные-значения)
+ [4.4 Попарное тестирование](#44-попарное-тестирование)
+ [4.5 Диаграмма состояния и переходов](#45-диаграмма-состояния-и-переходов)
+ [4.6 Таблица принятия решений](#46-таблица-принятия-решений)

[Оглавление](/TestingBegin/README.md)

# 4.1 Планета тест-дизайна

[Планета тест-дизайна](https://youtu.be/6pAq4zvYtFU)

<hr>

[Содержание](#содержание)

# 4.2 Зачем "дизайн" тестировщику?

[Видео-шпаргалка урока "Зачем "дизайн" тестировщику?"](https://youtu.be/Kc_B1oChT30)

## Что такое тест дизайн?

Если говорить формально, то **тест-дизайн** — это процесс создания тестов. Каждый тест предназначен для проверки определенного предположения. 

Задача специалиста — найти баланс и выявить максимальное количество ошибок при необходимом минимуме тестовых сценариев. При этом нужно проверить все наиболее важные кейсы, поскольку время тестирования ограничено.

Например, если нам необходимо протестировать калькулятор: сколько же может быть проверок? 

Целые и дробные числа, положительные и отрицательные… Это все надо сложить, разделить, возвести в степень и тд. Здесь не хватит времени, а чем быстрее продукт готов к релизу, тем быстрее компания начнет зарабатывать деньги. 

Именно тут нам на помощь приходят техники тест-дизайна. 

+ Классы эквивалентности;
+ Граничные значения;
+ Попарное тестирование;
+ Диаграмма состояния и переходов;
+ Таблица принятия решений.

Более подробно основные техники мы будем рассматривать в следующих уроках. 

Но будем помнить о том, что они часто используются в комплексе. Недостаточно одной техники, потому что она не сможет обеспечить максимальный охват тестового сценария.

Разумеется, этот список далеко не полон и дает только самое общее представление о принципах тестирования и техниках тест-дизайна.

Например, исчерпывающее тестирование, покрывающее все возможные сценарии и обнаруживающее все ошибки, существует только в теории, а на практике это невозможно. Это связано с тем, что проверка всех параметров и состояний займет слишком много времени (вспомним пример с калькулятором).

Однако, чем опытнее специалист, тем лучших результатов он может добиться, и для этого важно уметь правильно подбирать и комбинировать техники. 

Здесь можно вспомнить еще одну из техник тест дизайна: предугадывание ошибок. 

Предугадывание ошибок — это способ предотвращения ошибок, дефектов и отказов, основанный на знаниях тестировщика, включающих:

+ Историю работы приложения в прошлом;
+ Наиболее вероятные типы дефектов, допускаемых при разработке;
+ Типы дефектов, которые были обнаружены в схожих приложениях

Эта техника всегда идет в комбинации с какой-то другой (только пользуясь предугадыванием качественного тестирования не будет), а также с большим опытом тестировщика плюс отличное знание тестируемого продукта. 

Также, стоит упомянуть прием "4 действия с объектом". Например, нам необходимо протестировать объект "Пользователь" в социальной сети:

1. Создание аккаунта;
2. Просмотр страницы аккаунта;
3. Редактирование информации аккаунта;
4. Удаление аккаунта.

<hr>

[Содержание](#содержание)

# 4.3 Классы эквивалентности и граничные значения

[Видео-шпаргалка урока "Классы эквивалентности и граничные значения"](https://youtu.be/i3aSjMUGFpc)

## Классы эквивалентности и граничные значения

**Классы эквивалентности** — это разделение функциональности системы или обрабатываемых  данных на определенные группы значений (диапазоны), которые тестируемое приложение должно обрабатывать одинаково.

Лучше всего разобрать это утверждение на примере.

В данном уроке мы будем рассматривать минимальное количество проверок, исключая большое количество негативных и расширенных (например, дробный возраст и т.д.). Мы это делаем для более пристального внимания к примерам, касающихся урока. 

Предположим, у нас есть сайт винного магазина. Нам необходимо протестировать, что лиц, возрастом до 18 лет сайт не пускает, в то время как для пользователей с 18 (включая 18) доступ открыт. 

Чтобы проверить данный интервал, необходимо будет провести проверки возраста от 0 до 18 (это вроде не сильно много), с 18 сайт должен пускать. И тут уже проверок гораздо больше от 18 и как минимум до 100. 

Ну в принципе всего 100 раз ввести число и нажать кнопку — это не должно быть трудно, но представим, что на этом сайте еще и скидка при покупке от 3000 р. 

То есть сначала 100 проверок на возраст, а потом всего 3000 (если без копеек) проверок для теста отсутствия скидок, ну и до бесконечности проверок, что наш покупатель получит свою скидку в 10 %. 

Теперь понятно почему на собеседованиях спрашивают: как вы относитесь к монотонной работе?

Именно для этого и существуют эквивалентные значения. Исходя из нашей задачи, мы можем определить 2 группы эквивалентных значений для наших проверок: 

Возраст:

+ 0 - 17
+ 18 - 100

Так как данные внутри этих групп эквиваленты, нам нет смысла проверять их все. Нам достаточно проверить, что хотя бы 1 значение из группы работает корректно. 

То есть из бесконечного количества проверок мы делаем всего 4: 

+ Проверяем любое значение от 0-17. Например, 9;

+ Проверяем любое значение от 18-100. Например, 55;

**Граничные значения** — это значения, в которых один класс эквивалентности переходит в другой диапазон. 

Разберем на уже знакомом примере.  Если мы визуально изобразим классы (промежутки значений), которые мы проверили ранее, то увидим, что у нас есть точки вне проверки. Именно эти точки и являются граничными значениями. То есть в наш список добавляем две проверки на 0 и на 18. 

![04](/TestingBegin/img/04_01.png)

Путем долгого наблюдения за разработкой и анализа багов, специалисты пришли к выводу, что большинство ошибок возникает именно на границах между классами эквивалентности. То есть нам, в первую очередь, важно проверить переходы на стыке границ каждого класса, так как именно там велик риск возникновения ошибок.

На каждой границе диапазона следует проверить по три значения:

+ Граничное: 0, 18 и 100.

+ Шаг внутрь границ: -1 для 0, 17 для 18 и 99 для 100.

+ Шаг за границы: 1 для 0, 19 для 18 и 101 для 100.

Теперь смотрим на наш график и понимаем, что необходимо проверить: 

![04](/TestingBegin/img/04_02.png)

В итоге, благодаря технике тест-дизайна классы эквивалентности и граничные значения мы получаем вместо 100+ проверок всего 11. 

Таким образом, классы эквивалентности помогают нам группировать входные данные, а граничные значения позволяют проверить поведение приложения на крайних значениях.

## Практическое задание:

Вам предоставляется задача разработки функции для проверки корректности пароля. Пароль должен соответствовать следующим требованиям:
- Длина пароля должна быть от 6 до 12 символов.
- Пароль должен содержать хотя бы одну цифру.
- Пароль должен содержать хотя бы одну заглавную букву.
- Пароль должен содержать хотя бы одну строчную букву.
- Пароль может содержать только символы из следующего набора: a-z, A-Z, 0-9.

Составьте необходимые тесты. Поделитесь своим решением в комментарии.

<hr>

[Содержание](#содержание)

# 4.4 Попарное тестирование

## Попарное тестирование

**Попарное тестирование (Pairwise Testing)** — техника тест-дизайна, при которой тестовые сценарии разрабатываются таким образом, чтобы выполнить все возможные отдельные комбинации каждой пары входных параметров.

Данная техника тест-дизайна нужна, чтобы сразу продумать, что и как проверять, а потом тратить намного меньше времени на исполнение и поиск багов, сокращать общее количество тест-кейсов, тем самым уменьшая время и расходы, затраченные на тестирование.

Этот метод был придуман после многих лет наблюдений за багами, так сказать. Было замечено, что большинство дефектов вызвано взаимодействием не более двух факторов (дефекты, которые возникают при взаимодействии трех и более факторов, как правило, менее критичны) и нет никакого смысла проверять все возможные комбинации значений для всех факторов. Поэтому создается подмножество комбинаций, чтобы удовлетворить все факторы.

Метод попарного тестирования очень полезен при разработке тестов для приложений, включающих несколько параметров. Тесты разработаны таким образом, что для каждой пары входных параметров системы существуют всевозможные комбинации этих параметров. Набор тестов охватывает все комбинации, не является исчерпывающим, но очень эффективен для поиска ошибок.

Рассмотрим попарное тестирование на примере приложения «Музыка», которое:

+ работает на iOS и Android;
+ имеет два режима громкости: «Низкая» и «Высокая»;
+ имеет две скорости воспроизведения: «Нормальная» и «Ускоренная».

Для того чтобы получить все возможные комбинации, создадим таблицу:

+ Первый столбец - номер теста.
+ Второй столбец - операционная система, которую мы будем использовать во время тестирования.
+ Третий столбец - уровень громкости, которую мы будем указывать при тестировании.
+ Четвертый столбец - необходимая скорость воспроизведения для теста.

В данной таблице указаны все комбинации наших параметров. У нас получилось 8 тестов.

![04](/TestingBegin/img/04_03.png)

Для упрощения минимизации количества тестов необходимо сделать так, чтобы два любых столбца (в нашем случае это параметры ОС, Громкость и Скорость) содержали в себе все возможные комбинации только один раз:

![04](/TestingBegin/img/04_04.png)

Как видно, если брать попарно любые 2 столбца с параметрами, то в таблице есть все возможные комбинации и достаточно проверить 4 сценария, вместо 8.

![04](/TestingBegin/img/04_05.png)

На сайте https://www.pairwise.org/tools  представлены все инструменты, которые помогут качественно и быстро создать тест-кейсы из большого количества параметров. Самые популярные  из них:

[PICT](https://github.com/microsoft/pict) – Попарное независимое комбинаторное тестирование от Microsoft Corp.;

[IBM FoCuS](http://researcher.ibm.com/project/1871) – Единое решение для функционального покрытия от IBM;

[ACTS](http://csrc.nist.gov/acts) – Расширенная комбинаторная система тестирования от NIST, агентства правительства США;

[Hexawise](https://hexawise.com/);

[Jenny](http://burtleburtle.net/bob/math/jenny.html);

[Pairwise](https://inductive.no/pairwiser/) от Inductive AS;

[VPTag](https://sourceforge.net/projects/vptag/) – бесплатный инструмент попарного тестирования

Практическое задание:
Вам необходимо применить метод попарного тестирования для разработки тестов для приложения "Регистрация пользователя". Приложение имеет следующие параметры:

1. Вид учетной записи:
   - Аккаунт Google
   - Аккаунт Facebook
   - Аккаунт Twitter

2. Пол:
   - Мужской
   - Женский

3. Страна:
   - США
   - Великобритания
   - Германия

4. Язык:
   - Английский
   - Немецкий
   - Французский

Поделитесь своим решением в комментарии.

<hr>

[Содержание](#содержание)

# 4.5 Диаграмма состояния и переходов

## Диаграмма состояний и переходов

**Диаграмма состояний и переходов** позволяет наглядно представить все возможные состояния системы и показать, какие события или условия приводят к переходам между ними. Это помогает разработчикам и тестировщикам лучше понять и проверить поведение системы и убедиться, что все состояния и переходы работают правильно. Переход от одного состояния к другому обычно чем-то обусловлен, например, каким-нибудь действием над объектом.

Тесты создаются для покрытия типичной последовательности состояний, покрытия каждого возможного состояния, покрытия каждого возможного перехода, проверки специфических последовательностей переходов, или для проверки недействительных переходов.

Представим, наша задача протестировать мессенджер со следующими функциями:

1. Сразу после получения сообщения чат помечается как непрочитанный.
2. Когда пользователь нажимает на чат, чтобы открыть его содержимое, чат помечается как прочитанный.
3. Пользователь может пометить ранее прочитанный чат как непрочитанный.
4. Пользователи могут удалять чаты (как прочитанные, так и непрочитанные), при этом чаты не могут быть восстановлены после их удаления.

Сначала нарисуем диаграмму процесса:

+ Состояние "Прочитано" может переходить в состояние "Не прочитано" и "Удалено".
+ Состояние Не прочитано может переходить в состояние "Прочитано" и "Удалено".
+ Состояние "Удалено" является невозвратным.

![04](/TestingBegin/img/04_06.png)


Теперь напишем таблицу в виде матрицы, где укажем все состояния по горизонтали и вертикали. По вертикали указывается текущее состояние, а по горизонтали состояния для перехода.

![04](/TestingBegin/img/04_07.png)

После, заполним таблицу, чтобы определить все позитивные и негативные сценарии перехода одного состояния в другое:

+ Зеленый - возможные переходы. Это необходимо для определения позитивных тестов.
+ Красный - невозможные переходы. Это необходимо для определения негативных тестов.
+ Серый - главная диагональ, отражающая невозможность перехода текущего состояния в себя же.

![04](/TestingBegin/img/04_08.png)

Итак, мы видим, что всего необходимо протестировать шесть сценариев - четыре положительных и два отрицательных.

В заключение, техника тест-дизайна диаграммы состояний и переходов предоставляет понятное и наглядное описание поведения системы. Она помогает разработчикам и тестировщикам более эффективно анализировать и проверять работу программы или системы. Внедрение данной техники в процесс разработки может значительно повысить качество и надежность программного обеспечения.

## Практическое задание:

Вам необходимо создать диаграмму состояний и переходов для приложения "Автомат по продаже напитков".

Автомат имеет три состояния: "Ожидание выбора напитка", "Внесение денег" и "Выдача напитка".

Существуют следующие переходы: "Выбор напитка", "Внесение денег", "Отмена операции" и "Выдача напитка".

После выдачи напитка автомат возвращается в состояние "Ожидание выбора напитка".

Поделитесь своим решением в комментарии.

<hr>

[Содержание](#содержание)

# 4.6 Таблица принятия решений

## Таблицы принятия решений

Знаете ли вы, что такое комбинаторика и как ей пользоваться? Если да, то вы — красавчики, и нам понадобится лишь небольшая часть ваших знаний. Если же нет, то не переживайте, мы пробежимся по самым-самым верхам, чтобы у вас появилось представление. И конечно, сходим в википедию.

**Комбинато́рика** (иногда называемая комбинаторным анализом) — раздел математики, посвященный решению задач, связанных с выбором и расположением элементов некоторого (чаще всего конечного) множества в соответствии с заданными правилами.

Итак, у нас есть конечное множество, то есть, говоря по-простому, несколько штук чего-то. Чего конкретно, не столько важно: яблок, бананов, машин или людей. Просто конечное множество — сколько-то штук, причём мы знаем, сколько именно. И нам из этого количества штук надо либо выбрать несколько, либо расположить их в нужном порядке.

«В соответствии с заданными правилами» — что это значит? Представьте, что нам дали несколько штук чего-то, а еще дали правило, по которому их надо выбрать или расположить. Звучит не так уж и сложно, но всё же немного непонятно, как именно это делается. Давайте рассмотрим простой пример:

В классе учится 16 мальчиков и 10 девочек. Сколькими способами можно назначить одного дежурного?

Формулировка вопроса интуитивно понятна. Есть конечное множество (26 детей), есть применяемое к нему правило (назначить дежурного). Здесь мы подключаем эрудицию, бытовой опыт, космические силы и понимаем, что «назначить одного дежурного» означает «выбрать одного ребёнка». Сколько разных детей можно выбрать из 26?

У нас есть 26 детей, из них одного дежурного можно назначить 26 способами. Разными способами. Как только попробуем назначить 27-ым способом, повторим один из предыдущих 26-ти (назначим ребёнка, которого уже назначали).

Если вдруг после предыдущего шага вы не понимаете, что происходит и сомневаетесь, стоит ли читать дальше, то не пугайтесь. Нам важно было всего лишь настроиться на нужную волну, и не более того. Сейчас перейдём к тестированию, и всё будет куда понятнее.

Итак, таблица принятия решений состоит из возможных условий (входных данных, ввода), правил (сочетания входных данных) и действий, определяемых правилами.

Знакомая терминология, не правда ли?

Рассмотрим простейший пример ввода пароля. Пароль может быть либо верным, либо неверным — нам дано два условия. Соответственно, при вводе верного пароля пользователь получит доступ, а при вводе неверного пароля — не получит доступ. Так, мы получаем условие «правильность пароля» (верный/неверный) и действия «дать доступ» и «не дать доступ».

|**Условие**| |  |
-|-|-
Правильность пароля | Пароль верный | Пароль неверный
**Действие** |   |  
Дать доступ | Да | Нет

«Да» и «Нет» здесь заменяют «дать доступ» и «не дать доступ», позволяя сократить строки с действиями до одной. Также можно использовать и другие обозначения, например, 1 и 0, или Y и N от английских Yes и No, или T и F от True и False — ваш выбор.

Таблица выглядит всё ещё не очень интересно. К тому же, в ней только условие и действие, а правила-то где? Правилами мы назвали сочетания условий, а какими могут быть сочетания, если условие только одно? Правильно, никакими. А давайте добавим второй пароль! Вот такая у нас система: сначала надо ввести один пароль, потом второй пароль, и только потом система даёт доступ. Очевидно, у второго пароля условие то же самое — верный/неверный.

Но пароль уже другой, поэтому его надо вынести отдельно. Плюс должны появиться правила. А правила — это сочетания условий. Поэтому мы вынесем возможные сочетания в таблицу. Для удобства используем «1» и «0» — для обозначения положительного и отрицательного результата (верный/неверный, дать/не дать).

**Условия** | Правило 1 | Правило 2 | Правило 3 | Правило 4
------- | --------- | --------- | --------- | ---------
Правильность пароля №1 | 1 | 1 | 0 | 0
Правильность пароля №2 | 1 | 0 | 1 | 0
**Действие** |   |   |   |  
Дать доступ | 1 | 0 | 0 | 0

Красивое. И наглядное. Давайте попробуем расписать текстом то, что мы видим в таблице. Спойлер: получится муторно и нечитабельно.

Правило 1: если пароль 1 верный и пароль 2 верный дать доступ.

Правило 2: если пароль 1 верный, а пароль 2 неверный не давать доступ.

Правило 3: если пароль 1 неверный, а пароль 2 верный не давать доступ.

Правило 4: если пароль 1 неверный и пароль 2 неверный не давать доступ.

Представьте, что вам нужно проверить эти правила, сверяясь с документацией. Куда удобнее смотреть — в таблицу или в текст? Большинству в таблицу. К тому же, это в нашем примере условия тривиальные, а правила очевидные. А представьте, что вам нужно протестировать схожее поведение в системе, правила которой абсолютно неинтуитивные и взяты из написанной сухим языком документации.

## Практическое задание 6

Составление таблицы принятия решений - не самая тривиальная и распространенная задача, в связи с чем реализовать её проверку с помощью интерфейса платформы нам не удалось. Возможно, в будущем мы это исправим, а сейчас правильный ответ на подобные задания приложен в виде ссылки на таблицу, с которой можно свериться для проверки своего решения. Приносим извинения за неудобства. 

Мы должны протестировать автоматизированную систему контроля результатов медицинских анализов. Задача системы в том, чтобы по результатам нескольких анализов одного пациента определять его либо здоровым, либо больным. Пациент сдаёт 3 анализа, результат каждого может быть определён как норма или патология (не норма). Пациенты без патологий или одной патологией в анализах определяются системой как здоровые, с двумя или тремя патологиями — больные. 

Составьте таблицу принятия решений данной системой (анализы обозначьте анализ 1, анализ 2, анализ 3 или по собственному желанию)

Правильный ответ: [Таблица медицинские анализы](https://docs.google.com/document/d/1bTdoy21s14aIEjUSc1GvUciDEpsQpCYgR57gAZJ17oU/edit?usp=sharing)

Давайте рассмотрим на конкретном примере, как применять правила из наших таблиц.

Начнем с того, что не только условий, но и действий может быть много, гораздо больше 1 или 2. Возьмем систему с двумя паролями из предыдущего урока. Давайте предположим, что если пользователь ввел неверный первый пароль, то вводить второй ему уже не дают — сразу же отказывают в доступе. Таким образом, у нас добавляется новое действие, назовём его: Ввести пароль №2.

Условия | Правило 1 | Правило 2 | Правило 3 | Правило 4
-- | -- | -- | -- | --
Правильность пароля №1 | 1 | 1 | 0 | 0
Правильность пароля №2 | 1 | 0 | 1 | 0
Действие |   |   |   |  
Ввести пароль №2 | 1 | 1 | 0 | 0
Дать доступ | 1 | 0 | 0 | 0

Теперь на основе этой таблицы нужно протестировать систему. Каждое правило — это набор шагов с ожидаемым результатом. Ввели в систему сочетание условий (правил), получили результат, сравнили с ожидаемым результатом (действиями).

Но, если подумать, то 4 теста для проверки нам будет много. Давайте рассуждать логически: как только пользователь ввел неверный пароль №1, ему тут же не дают вводить пароль №2. То есть Правило 3 и Правило 4 при реальных проверках дадут один и тот же результат. Так, до ввода пароля №2 дело не дойдёт. Давайте изменим формулировки и распишем нужные проверки.

Шаги | Тест 1 | Тест 2 | Тест 3
-- | -- | -- | --
Пароль №1 введён правильно | 1 | 1 | 0
Пароль №2 введён правильно | 1 | 0 |  
Ожидаемые результаты |   |   |  
Появилось поле ввода пароля №2 | 1 | 1 | 0
Пользователю дан доступ | 1 | 0 | 0

Вот мы и увидели, как на основе таблицы решений составлять тесты.

## Практическое задание 6
Мы говорили о том, что и условий, и действий может быть много. В нашем случае легко представить, что добавился третий пароль, а за ним четвертый, пятый и т. д. Но давайте всё же выйдем из этой плоскости. Предположим, что в нашей системе есть пароль суперадмина, который надо вводить в качестве первого пароля, тогда без ввода второго пользователю будет дан доступ в систему. И более того, доступ будет с правами суперадмина.

Составьте полную (содержащую невозможные в реальности сочетания условий) таблицу решений для такой ситуации. Для целей задачи считать, что доступ суперадмина дается только при сочетании условий «Первый пароль введён правильно» и «Введён пароль суперадмина».

Правильный ответ: [Таблица пароль суперадмина](https://docs.google.com/document/d/1wtnNixzG4aIz8IyQpuIfSgzEh5wqMOmLcHtU4Teg2pg/edit?usp=sharing)

Есть и ещё одно применение для таблицы решений. Оно не даст нам сразу готовый набор тестов, но наглядно продемонстрирует, какие именно ситуации важно протестировать. Так, мы сможем написать набор тестов для каждой ситуации и быть уверенными, что ничего не забыли.

В прошлом уроке мы рассматривали исключительно бинарные параметры. Пароль либо правильный, либо неправильный, а доступ либо даётся, либо нет. Поэтому обозначения правил в виде единичек и ноликов очень удобно. 

Давайте отвлечемся от примера с паролями и представим другую ситуацию: мы тестируем корректность отображения комиссии при переводе в банковском приложении. Предположим, что при сумме перевода до 100 тыс. руб. комиссия не взимается, а от 100 тыс. руб.  и до 200 тыс. руб. включительно комиссия составляет 0,5%. Свыше 200 тыс. руб. комиссия фиксирована в размере 1 тыс. р. за перевод.

Внимание, вопрос: можем ли мы отразить это в виде таблицы с бинарными условиями и действиями? Конечно, можем! Будет ли это удобно? А это уже второй вопрос!

Условия | Правило 1 | Правило 2 | Правило 3
-- | -- | -- | --
< 100к | 1 | 0 | 0
100к-200к | 0 | 1 | 0
200к < | 0 | 0 | 1
Действия |   |   |  
Комиссии нет | 1 | 0 | 0
Комиссия 0,5% | 0 | 1 | 0
Комиссия 1000р. | 0 | 0 | 1

Итак, что мы видим? Правило, являющееся сочетанием условий, выдает нам сочетание действий. Давайте попробуем текстом написать первое правило и посмотреть, что получится.

Правило 1. Если сумма перевода менее 100 тыс. руб. и не входит в промежуток 100 тыс.-200 тыс. , а при этом не более 200тыс. руб., то комиссия не взимается, и не составляет 0,5% и 1000 руб.

Текст выглядит не менее странно, чем таблица. Дело в том, что у нас одно условие автоматически делает невозможными два других. То же самое и с действиями. Поэтому текст выглядит избыточным. Попробуем его переписать по-человечески и получим условие из изначальной задачи

Правило 1. Если сумма перевода менее 100 тыс. руб., то комиссия не взимается.

Вот, гораздо лучше. А можно ли это как-то уложить в таблицу? Давайте попробуем! Только для этого нам нужно отойти от бинарных параметров.

Условия | Правило 1 | Правило 2 | Правило 3
-- | -- | -- | --
Размер перевода | <100к | 100к-200к | 200к <
Действия |   |   |  
Комиссия | 0 | 0,50% | 1000р.

Согласитесь, неплохо получилось. Правда, мы уже знакомы с граничными значениями и понимаем, что трёх проверок нам не хватит. Важно обязательно попробовать размер перевода 99 999,99 и т.д. Но мы получили набор классов эквивалентности для позитивных проверок, а это уже отлично. Только набор у нас с одним условием получился весьма простым. 

Давайте представим, что у банковских клиентов может быть обычный, премиальный или VIP-статус. Для премиальных клиентов комиссия за перевод 100к-200к не взимается, а за переводы более 200к составляет 0,25%. VIP-клиенты вообще делают любые переводы без комиссии. Воспользуемся небинарным параметром статуса и отобразим все правила в новой таблице. 

Условия | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
-- | -- | -- | -- | -- | -- | -- | -- | -- | --
Размер перевода | < 100к | 100к-200к | 200к < | < 100к | 100к-200к | 200к < | < 100к | 100к-200к | 200к <
Статус | Обычный | Обычный | Обычный | Прем. | Прем. | Прем. | VIP | VIP | VIP
Действия |   |   |   |   |   |   |   |   |  
Комиссия | 0 | 0,50% | 1000р. | 0 | 0 | 0,25% | 0 | 0 | 0

Большая и красивая таблица. Оставим её без комментариев, просто молча полюбуемся.

Пожалуй, таблицы решений уже изучены нами вдоль и поперёк. Осталось добавить лишь пару мелких нюансов, способных сделать их применение ещё более удобным.

Начнём с того, что таблица решений — лишь один из инструментов, и она необязательно должна использоваться всегда и везде. Любой инструмент приспособлен для выполнения одних задач и не очень полезен для других.

Таблицу решений удобно применять в тех случаях, когда поведение системы определяется несколькими параметрами, у каждого из которых может быть несколько значений. Как только видите множественные формулировки типа: «если A такое, а B вот такое, то C, иначе D», «при A больше стольки и B меньше стольки происходит C, в обратном случае D» — это тот случай, когда вам пригодится навык создания таблиц решений.

Количество сочетаний (количество правил, количество столбцов/ширина таблицы) определяется перемножением количества возможных вариантов каждого параметра.

Помните задачу с двумя кубиками, где мы получили, что общее количество сочетаний равно 36? Аналогично в примере с суммами перевода (3 варианта) и статусами клиентов (тоже 3 варианта). Итоговое количество правил оказалось равным 9. Если у нас есть 3 параметра, у первого из которых два возможных значения, у второго три, а у третьего четыре, то количество правило будет равно 2×3×4 = 24. Сразу можно задать нужную ширину таблице, чтобы не пропустить правило.

Любую таблицу решений можно представить в виде бинарных параметров, но далеко не всегда это удобно. Использование конкретных значений каждого условия повышает читаемость таблицы.

Разные правила могут приводить к одному и тому же действию (сочетанию действий), но это далеко не всегда означает, что при тестировании какое-то правило можно пропустить, как в нашем примере с двумя паролями. К подобным моментам всегда важно подходить аккуратно и с особой тщательностью, чтобы не «отрезать лишнего».

Итак, мы закончили изучать таблицы решений. Впереди много практики, которая сделает из вас настоящих мастеров составления таблиц решений, удачи!

## Практическое задание 6.2

**Задание 1**

В стране N действует прогрессивная ставка подоходного налога. Если налогоплательщик зарабатывает менее 25 000 в год, его доход облагается по ставке 5%, если от 25 000 до 75 000, то по ставке 10%, если более 75 000, то 20%. При этом налоговая ставка изменяется в зависимости от отрасли, в которой работает налогоплательщик: торговля увеличивает ставку на 2 процента, сельское хозяйство уменьшает на 1 процент, здравоохранение уменьшает на 3 процента. Остальные отрасли не меняют ставку налога.

Составить таблицу решений.

Правильный ответ: [Таблица подоходный налог](https://docs.google.com/document/d/1H-acYy8pw6yQLsV1zdLbAH1rnGQboB7yt9rdOOgqykM/edit?usp=sharing)

**Задание 2.**

Составьте таблицу решений для результатов броска двух трехгранных кубиков (на каждом кубике можно выбросить цифры 1, 2, 3). Результатом броска считается выброшенная сумма.

Правильный ответ [Таблица трёхгранные кубики](https://docs.google.com/document/d/1u9bo2T10Kpo3yBNJBA47cKmahInuDXN8__eO-v4RxhM/edit?usp=sharing) 

**Задание 3.**

При регистрации на сайте пароль обязательно должен содержать цифры и большие буквы. В противном случае пользователю показывается сообщение с просьбой изменить пароль. Если в пароле содержится хотя бы один спецсимвол, пользователю показывается сообщение, что использование спецсимволов в паролях — отличное решение. Составьте таблицу решений.

Правильный ответ [Таблица символы в пароле](https://docs.google.com/document/d/1MaUpZZ09GgkjmM307tewwg5ONkG1YdLWKc8ZkLKY1y4/edit?usp=sharing)

<hr>

[Содержание](#содержание)